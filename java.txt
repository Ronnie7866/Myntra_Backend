// File: AuthenticationRequest.java

package com.backend.ecommerce.authentication;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AuthenticationRequest {

    private String email;
    private String password;
}


// File: AuthenticationResponse.java

package com.backend.ecommerce.authentication;

import com.backend.ecommerce.records.UserDTO;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AuthenticationResponse {
    private String token;
    private UserDTO userDTO;
}


// File: OAuthAuthenticationSuccessHandler.java

package com.backend.ecommerce.authentication;

import com.backend.ecommerce.entity.User;
import com.backend.ecommerce.enums.Role;
import com.backend.ecommerce.repository.UserRepository;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.core.user.DefaultOAuth2User;
import org.springframework.security.web.DefaultRedirectStrategy;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.Objects;
import java.util.Random;
import java.util.UUID;

@Component
public class OAuthAuthenticationSuccessHandler implements AuthenticationSuccessHandler {

    private final UserRepository userRepository;

    @Autowired
    public OAuthAuthenticationSuccessHandler(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {

        DefaultOAuth2User googleUser = (DefaultOAuth2User) authentication.getPrincipal();

        String firstName = Objects.requireNonNull(googleUser.getAttribute("given_name")).toString();
        String lastName = Objects.requireNonNull(googleUser.getAttribute("family_name")).toString();
        String email = Objects.requireNonNull(googleUser.getAttribute("email")).toString();

        // create user and save in database
        User user = new User();
        user.setFirstName(firstName);
        user.setLastName(lastName);
        user.setEmail(email);
        Random random = new Random();
        Long userId = random.nextLong() & Long.MAX_VALUE;
        user.setId(userId);
        user.setPassword("password");
        user.setRole(Role.USER);

        User DBUser = userRepository.findByEmail(email).orElse(null);

        if (DBUser == null) {
            userRepository.save(user);
            System.out.println("User saved Successfully");
        }
        System.out.println("User exists ");
        new DefaultRedirectStrategy().sendRedirect(request, response, "http://localhost:5173/");
    }
}


// File: RegisterRequest.java

package com.backend.ecommerce.authentication;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class RegisterRequest {

    private String firstName;
    private String lastName;
    private String email;
    private String password;
}


// File: S3Config.java

package com.backend.ecommerce.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.presigner.S3Presigner;

@Configuration
public class S3Config {

    @Value("${cloud.aws.credentials.access-key}")
    private String accessKey;

    @Value("${cloud.aws.credentials.secret-key}")
    private String secretKey;

    @Value("${cloud.aws.region.static}")
    private String region;

    @Bean
    public S3Client s3Client() {
        AwsBasicCredentials awsCredentials = AwsBasicCredentials.create(accessKey, secretKey);

        return S3Client.builder()
                .region(Region.of(region))
                .credentialsProvider(StaticCredentialsProvider.create(awsCredentials))
                .build();
    }

    @Bean
    public S3Presigner s3Presigner() {
        AwsBasicCredentials awsCredentials = AwsBasicCredentials.create(accessKey, secretKey);

        return S3Presigner.builder()
                .region(Region.of(region))
                .credentialsProvider(StaticCredentialsProvider.create(awsCredentials))
                .build();
    }
}


// File: AddressController.java

package com.backend.ecommerce.controllers;


import com.backend.ecommerce.entity.Address;
import com.backend.ecommerce.repository.AddressRepository;
//import com.backend.ecommerce.implementation.AddressService;
import com.backend.ecommerce.service.AddressService;
import com.backend.ecommerce.service.UserService;
import lombok.AllArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/address")
@AllArgsConstructor
public class AddressController {

    private final UserService userService;
    private final AddressRepository addressRepository;
    private final AddressService addressService;

    @PostMapping("/{userId}")
    public ResponseEntity<Address> createAddress(@PathVariable Long userId, @RequestBody Address address) {
        Address save = addressService.save(userId, address);
        return ResponseEntity.ok().body(save);
    }

    @GetMapping
    public ResponseEntity<List<Address>> getAllAddress() {
        List<Address> addressList = addressService.getAll();
        return ResponseEntity.ok().body(addressList);
    }

    @GetMapping("/{id}")
    public ResponseEntity<Address> getAddressByUserId(@PathVariable Long id) {
        Address address = addressService.getAddressByUserId(id);
        return ResponseEntity.ok(address);
    }

    @DeleteMapping
    public ResponseEntity<String> deleteAddress(@RequestBody Address address) {

        addressService.deleteAddressById(address.getId());
        return ResponseEntity.ok("Address is deleted");
    }

    @PutMapping("/{userId}")
    public ResponseEntity<Address> updateAddressByUserId(@RequestBody Address address, @PathVariable Long userId) {
        Address address1 = addressService.updateAddressByUserId(address, userId);
        return ResponseEntity.ok().body(address1);
    }
}


// File: AuthenticationController.java

package com.backend.ecommerce.controllers;

import com.backend.ecommerce.authentication.AuthenticationRequest;
import com.backend.ecommerce.authentication.AuthenticationResponse;
import com.backend.ecommerce.authentication.RegisterRequest;
import com.backend.ecommerce.entity.User;
import com.backend.ecommerce.implementation.AuthenticationService;
import com.backend.ecommerce.repository.UserRepository;
import com.backend.ecommerce.security.JWTService;
import com.backend.ecommerce.utility.JwtBlacklistService;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.client.authentication.OAuth2AuthenticationToken;
import org.springframework.security.oauth2.core.user.OAuth2User;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

@RestController
@RequestMapping("/api/auth")
@CrossOrigin
public class AuthenticationController {

    private final AuthenticationService authenticationService;
    private final JwtBlacklistService jwtBlacklistService;
    private final UserRepository userRepository;

    @Autowired
    public AuthenticationController(AuthenticationService authenticationService, JwtBlacklistService jwtBlacklistService, UserRepository userRepository) {
        this.authenticationService = authenticationService;
        this.jwtBlacklistService = jwtBlacklistService;
        this.userRepository = userRepository;
    }

    @PostMapping("/register")
    public ResponseEntity<AuthenticationResponse> register(@RequestBody RegisterRequest request) {
        AuthenticationResponse registered = authenticationService.register(request);
        return new ResponseEntity<>(registered, HttpStatus.CREATED);

    }

    @PostMapping("/authenticate")
    public ResponseEntity<AuthenticationResponse> authenticate(@RequestBody AuthenticationRequest request) {
        return ResponseEntity.ok(authenticationService.authenticate(request));
    }

    @PostMapping("/logout")
    public ResponseEntity<String> logout(HttpServletRequest request) {
        String autheader = request.getHeader("Authorization");
        if (autheader != null && autheader.startsWith("Bearer ")) {
            String token = autheader.substring(7);
            jwtBlacklistService.addBlacklist(token);
        }
        return new ResponseEntity<>("Logout Successful", HttpStatus.OK);
    }

//    @GetMapping("/user-info")
//    public String saveUser(OAuth2AuthenticationToken authentication) {
//        System.out.println("Method called");
//        Map<String, Object> attributes = authentication.getPrincipal().getAttributes();
//
//        attributes.forEach((key, value) -> {
//            System.out.println("Key: " + key + " Value: " + value);
//        });
//
//        String googleId = attributes.get("sub").toString();
//        String email = attributes.get("email").toString();
//        String name = attributes.get("name").toString();
//
//        // check if user already exists
//        User user = userRepository.findByGoogleId(googleId);
//        if (user == null) {
//            User newUser = new User();
//            newUser.setEmail(email);
//            newUser.setFirstName(name);
//            newUser.setLastName(name);
//            newUser.setGoogleId(googleId);
//            userRepository.save(newUser);
//        }
//        return "User saved successfully";
//    }
}


// File: CartController.java

package com.backend.ecommerce.controllers;

import com.backend.ecommerce.records.CartDTO;
import com.backend.ecommerce.entity.Cart;
import com.backend.ecommerce.entity.CartProducts;
import com.backend.ecommerce.dto.CartItemsDTO;
import com.backend.ecommerce.service.CartService;
import lombok.AllArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@AllArgsConstructor
@RequestMapping("/api/cart")
public class CartController {

    private final CartService cartService;

    @GetMapping
    public List<Cart> getAllCarts() {
        return cartService.getAllCarts();
    }

    @GetMapping("/user/{userId}")
    public List<CartItemsDTO> getCartItemsByUserId(@PathVariable Long userId) {
        return cartService.getCartItemsByUserId(userId);
    }

    @PostMapping
    public ResponseEntity<CartProducts> addProductToCart(@RequestParam Long userId, @RequestParam Long productId, @RequestParam Integer quantity){ // TODO change userID to RequestParam
        CartProducts cartProducts = cartService.addProductToCart(userId, productId, quantity);
        return ResponseEntity.ok(cartProducts);
    }

    @GetMapping("/{cartId}")
    public ResponseEntity<Cart> getCart(@PathVariable Long cartId){
        Cart cart = cartService.getCart(cartId);
        return ResponseEntity.ok(cart);
    }

    @GetMapping("/getCartByUserId/{userId}")
    public ResponseEntity<CartDTO> getCartByUserId(@PathVariable Long userId) {
        CartDTO cartByUserId = cartService.getCartByUserId(userId);
        return ResponseEntity.ok(cartByUserId);
    }
}


// File: CategoryController.java

package com.backend.ecommerce.controllers;


import com.backend.ecommerce.entity.Category;
import com.backend.ecommerce.records.CategoryDTO;
import com.backend.ecommerce.service.CategoryService;
import lombok.AllArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@AllArgsConstructor
@RequestMapping("/api/category")
public class CategoryController {

    private final CategoryService categoryService;


    @PostMapping
    public ResponseEntity<CategoryDTO> addCategory(@RequestBody Category category) {
        CategoryDTO category1 = categoryService.create(category);
        return new ResponseEntity<>(category1, HttpStatus.CREATED);
    }

    @GetMapping
    public ResponseEntity<List<CategoryDTO>> getAllCategories() {
        List<CategoryDTO> allCategories = categoryService.findAll();
        return ResponseEntity.ok(allCategories);
    }

    @GetMapping("/{id}")
    public ResponseEntity<CategoryDTO> getCategoryById(@PathVariable Long id) {
        CategoryDTO byId = categoryService.findById(id);
        if (byId != null) {
            return ResponseEntity.ok(byId);
        } else {
            throw new RuntimeException("Category not found");
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<CategoryDTO> updateCategory(@RequestBody Category category, @PathVariable Long id) {
        CategoryDTO updatedCategory = categoryService.update(category, id);
        return ResponseEntity.ok(updatedCategory);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteCategory(@PathVariable Long id) {
        String delete = categoryService.delete(id);
        return ResponseEntity.ok("Category deleted successfully");
    }

    @PostMapping("/batch")
    public ResponseEntity<List<CategoryDTO>> createCategory(@RequestBody List<Category> category) {
        List<CategoryDTO> listOfCategory = categoryService.createListOfCategory(category);
        return ResponseEntity.ok(listOfCategory);
    }

    @GetMapping("/")
    public ResponseEntity<List<CategoryDTO>> findListOfCategoryByProductId(@RequestParam Long productId) {
        List<CategoryDTO> categoryByProductId = categoryService.getCategoryByProductId(productId);
        return ResponseEntity.ok(categoryByProductId);
    }
}


// File: ColorController.java

package com.backend.ecommerce.controllers;

import com.backend.ecommerce.entity.Color;
import com.backend.ecommerce.implementation.ColorServiceImplementation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/colors")
public class ColorController {
    @Autowired
    private ColorServiceImplementation colorService;

    @PostMapping
    public Color createColor(@RequestBody Color color) {
        return colorService.createColor(color);
    }

    @GetMapping
    public List<Color> getColors() {
        return colorService.getAllColors();
    }
}


// File: ForgotPasswordController.java

package com.backend.ecommerce.controllers;

import com.backend.ecommerce.implementation.ForgotPasswordServiceImplementation;
import com.backend.ecommerce.records.ChangePassword;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/forgotPassword")
public class ForgotPasswordController {

    private final ForgotPasswordServiceImplementation forgotPasswordService;

    @Autowired
    public ForgotPasswordController(ForgotPasswordServiceImplementation forgotPasswordService) {
        this.forgotPasswordService = forgotPasswordService;
    }

    @PostMapping("/verifyMail/{email}")
    public ResponseEntity<String> verifyEmail(@PathVariable String email) {
        String s = forgotPasswordService.verifyEmail(email);
        return ResponseEntity.ok(s);
    }

    @PostMapping("/verifyOTP/{otp}/{email}")
    public ResponseEntity<String> verifyOTP(@PathVariable Integer otp, @PathVariable String email) {
        String s = forgotPasswordService.verifyOTP(otp, email);
        return ResponseEntity.ok(s);
    }

    @PostMapping("/changePassword/{email}")
    public ResponseEntity<String> changePasswordHandler(@RequestBody ChangePassword changePassword, @PathVariable String email) {
        String s = forgotPasswordService.changePasswordHandler(changePassword, email);
        return ResponseEntity.ok(s);
    }
}


// File: InventoryController.java

package com.backend.ecommerce.controllers;

import com.backend.ecommerce.entity.Inventory;
import com.backend.ecommerce.exception.InsufficientStockException;
import com.backend.ecommerce.exception.InventoryNotFoundException;
import com.backend.ecommerce.implementation.InventoryServiceImplementation;
import com.backend.ecommerce.records.InventoryDTO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/inventory")
public class InventoryController {

    private final InventoryServiceImplementation inventoryServiceImplementation;

    @Autowired
    public InventoryController(InventoryServiceImplementation inventoryServiceImplementation) {
        this.inventoryServiceImplementation = inventoryServiceImplementation;
    }
    @PostMapping("/{productId}")
    public ResponseEntity<?> addInventory(@PathVariable Long productId, @RequestParam int stock, @RequestHeader(value = "Authorization", required = false) String token) {
        if (token == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Authorization token invalid");
        }
        InventoryDTO inventory = inventoryServiceImplementation.addInventory(productId, stock);
        return new ResponseEntity<>(inventory, HttpStatus.CREATED);
    }

    @PutMapping("/{productId}")
    public ResponseEntity<InventoryDTO> updateStock(@PathVariable Long productId, @RequestParam int stock) {
        InventoryDTO inventory = inventoryServiceImplementation.updateStock(productId, stock);
        return new ResponseEntity<>(inventory, HttpStatus.OK);
    }

    @GetMapping("/{productId}")
    public ResponseEntity<InventoryDTO> getInventoryByProduct(@PathVariable Long productId) {
        InventoryDTO inventory = null;
        try {
            inventory = inventoryServiceImplementation.getInventoryByProduct(productId);
        } catch (InventoryNotFoundException e) {
            throw new RuntimeException(e);
        }
        return new ResponseEntity<>(inventory, HttpStatus.OK);
    }

    @GetMapping
    public ResponseEntity<List<InventoryDTO>> getAllInventories() {
        List<InventoryDTO> inventories = inventoryServiceImplementation.getAllInventory();
        return new ResponseEntity<>(inventories, HttpStatus.OK);
    }

    @PostMapping("/decrease/{productId}")
    public ResponseEntity<InventoryDTO> decreaseStock(@PathVariable Long productId, @RequestParam int quantity) {
        InventoryDTO inventory = null;
        try {
            inventory = inventoryServiceImplementation.decreaseStock(productId, quantity);
        } catch (InsufficientStockException | InventoryNotFoundException e) {
            throw new RuntimeException(e);
        }
        return new ResponseEntity<>(inventory, HttpStatus.OK);
    }

    @PostMapping("/increase/{productId}")
    public ResponseEntity<InventoryDTO> increaseStock(@PathVariable Long productId, @RequestParam int quantity) {
        InventoryDTO inventory = null;
        try {
            inventory = inventoryServiceImplementation.increaseStock(productId, quantity);
        } catch (InventoryNotFoundException e) {
            throw new RuntimeException(e);
        }
        return new ResponseEntity<>(inventory, HttpStatus.OK);
    }

    @GetMapping("/check/{productId}")
    public ResponseEntity<Boolean> isStockAvailable(@PathVariable Long productId, @RequestParam int quantity) {
        boolean isAvailable = false;
        try {
            isAvailable = inventoryServiceImplementation.isStockAvailable(productId, quantity);
        } catch (InventoryNotFoundException e) {
            throw new RuntimeException(e);
        }
        return new ResponseEntity<>(isAvailable, HttpStatus.OK);
    }

    @PostMapping("/bulk-update")
    public ResponseEntity<Void> bulkUpdateStock(@RequestBody Map<Long, Integer> stockUpdates) {
        try {
            inventoryServiceImplementation.bulkUpdateStock(stockUpdates);
        } catch (InventoryNotFoundException e) {
            throw new RuntimeException(e);
        }
        return new ResponseEntity<>(HttpStatus.OK);
    }
}


// File: OrderController.java

package com.backend.ecommerce.controllers;

import com.backend.ecommerce.dto.OrderRequest;
import com.backend.ecommerce.entity.Order;
import com.backend.ecommerce.enums.TransactionType;
import com.backend.ecommerce.implementation.OrderServiceImplementation;
import com.backend.ecommerce.service.OrderService;
import com.backend.ecommerce.service.payment.CheckoutService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.List;


@RestController
@RequestMapping("api/orders")
@RequiredArgsConstructor
public class OrderController {

    private final CheckoutService checkoutService;
    private final OrderServiceImplementation orderService;

    @PostMapping("checkout")
    public Order checkout(@RequestParam Long userId,
                          @RequestParam TransactionType transactionType,
                          @RequestParam BigDecimal transactionAmount) {
        return checkoutService.checkout(userId, transactionType, transactionAmount);
    }


    @PostMapping()
    public ResponseEntity<String> createOrder(@RequestBody OrderRequest orderRequest) {
        orderService.createOrder(orderRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body("Order created successfully");
    }

    @GetMapping("/{id}")
    public ResponseEntity<Order> getOrderById(@PathVariable long id) {
        Order order = orderService.getOrder((int) id);
        return ResponseEntity.ok(order);
    }

    @GetMapping
    public ResponseEntity<List<Order>> getAllOrders() {
        List<Order> allOrders = orderService.getAllOrders();
        return ResponseEntity.ok(allOrders);
    }

    @PostMapping("/convert/{cartId}")
    public Order convertCartToOrder(@PathVariable Long cartId) {
        return orderService.convertCartToOrder(cartId);
    }
}



// File: ProductController.java

package com.backend.ecommerce.controllers;


import com.backend.ecommerce.implementation.ProductServiceImplementation;
import com.backend.ecommerce.mapper.ProductMapper;
import com.backend.ecommerce.records.ProductDTO;
import com.backend.ecommerce.records.ProductResponse;
import com.backend.ecommerce.entity.Product;
import com.backend.ecommerce.service.CategoryService;
import com.backend.ecommerce.utility.AppConstants;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/products")
@CrossOrigin("*")

public class ProductController {

    private final ProductServiceImplementation productService;
    private final CategoryService categoryService;
    private final ProductMapper productMapper;

    @Autowired
    public ProductController(ProductServiceImplementation productService, CategoryService categoryService, ProductMapper productMapper) {
        this.productService = productService;
        this.categoryService = categoryService;
        this.productMapper = productMapper;
    }

    @PostMapping
    public ResponseEntity<?> createProduct(@RequestBody Product product, @RequestHeader(value = "Authorization", required = false) String token) {
        if (token == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Authorization token invalid");
        }

        String jwtToken = token.substring(7);

        ProductDTO savedProducts = productService.createProduct(product);
        return new ResponseEntity<>(savedProducts, HttpStatus.CREATED);
    }

    @PostMapping("/add-all")
    public ResponseEntity<List<ProductDTO>> createListProduct(@RequestBody List<Product> productList) {
        List<ProductDTO> products = productService.addAll(productList);
        return new ResponseEntity<>(products, HttpStatus.CREATED);
    }

    @GetMapping
    public ResponseEntity<List<ProductDTO>> getAllProducts() {
        List<ProductDTO> products = productService.getAllProducts();
        return ResponseEntity.ok(products);
    }
    @GetMapping("/{id}")
    public ResponseEntity<ProductDTO> getProductById(@PathVariable Long id) {
        ProductDTO productById = productService.getProductById(id);
        return ResponseEntity.ok(productById);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ProductDTO> updateProduct(@RequestBody Product product, @PathVariable Long id) {
        ProductDTO updatedProduct = productService.updateProduct(id, product);
        return ResponseEntity.ok(updatedProduct);
    }

    @PostMapping("/mapCategory")
    public ResponseEntity<ProductDTO> assignProductWithCategory(@RequestParam Long productId, @RequestParam Long categoryId) {
        ProductDTO product = productService.assignCategoryToProduct(productId, categoryId);
        return ResponseEntity.ok(product);
    }

    @GetMapping("/getProductByCategory/{id}")
    public ResponseEntity<List<ProductDTO>> getProductsByCategory(@PathVariable Long id) {
        List<ProductDTO> productByCategory = productService.getProductByCategory(id);
        return ResponseEntity.ok(productByCategory);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<ProductDTO> deleteProduct(@PathVariable Long id) {
        ProductDTO product = productService.deleteProduct(id);
        return ResponseEntity.ok(product);
    }

    @GetMapping("/allProductPage")
    public ResponseEntity<ProductResponse> getAllProductPage(@RequestParam(defaultValue = AppConstants.PAGE_NUMBER, required = false) Integer pageNumber,
                                                                   @RequestParam(defaultValue = AppConstants.PAGE_SIZE, required = false) Integer pageSize) {
        return ResponseEntity.ok(productService.getAllProductWithPagination(pageNumber, pageSize));
    }

    @GetMapping("/allProductPageWithPagination")
    public ResponseEntity<ProductResponse> getAllProductPage(@RequestParam(defaultValue = AppConstants.PAGE_NUMBER, required = false) Integer pageNumber,
                                                             @RequestParam(defaultValue = AppConstants.PAGE_SIZE, required = false) Integer pageSize,
                                                             @RequestParam(defaultValue = AppConstants.SORT_BY, required = false) String sortBy,
                                                             @RequestParam(defaultValue = AppConstants.SORT_ORDER, required = false) String sortOrder) {
        return ResponseEntity.ok(productService.getProductWithPaginationAndSorting(pageNumber, pageSize, sortBy, sortOrder));
    }

    @GetMapping("/search")
    public ResponseEntity<ProductResponse> searchProducts(
            @RequestParam String query,
            @RequestParam(defaultValue = "0") Integer pageNumber,
            @RequestParam(defaultValue = "10") Integer pageSize,
            @RequestParam(defaultValue = "name") String sortBy,
            @RequestParam(defaultValue = "asc") String sortOrder) {
        System.out.println("Executing method");

        // Log the input parameters
        System.out.println("Query: " + query);
        System.out.println("Page Number: " + pageNumber);
        System.out.println("Page Size: " + pageSize);
        System.out.println("Sort By: " + sortBy);
        System.out.println("Sort Order: " + sortOrder);

        ProductResponse response = productService.searchProducts(query, pageNumber, pageSize, sortBy, sortOrder);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/suggestions")
    public ResponseEntity<List<Product>> getProductSuggestions(
            @RequestParam String query) {
        List<Product> suggestions = productService.searchProducts(query);
        return ResponseEntity.ok(suggestions);
    }
}


// File: ProductImageController.java

//package com.backend.ecommerce.controllers;
//
//
//import com.backend.ecommerce.entity.ProductImageTable;
//import com.backend.ecommerce.implementation.FileServiceImplementation;
//import com.backend.ecommerce.implementation.ProductImageServiceImpl;
//import com.backend.ecommerce.implementation.ProductServiceImplementation;
//import com.backend.ecommerce.mapper.ProductImageMapper;
//import com.backend.ecommerce.records.ProductImageDTO;
//import com.backend.ecommerce.service.ProductImageService;
//import jakarta.servlet.http.HttpServletResponse;
//import lombok.AllArgsConstructor;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.beans.factory.annotation.Value;
//import org.springframework.http.MediaType;
//import org.springframework.http.ResponseEntity;
//import org.springframework.util.StreamUtils;
//import org.springframework.web.bind.annotation.*;
//import org.springframework.web.multipart.MultipartFile;
//
//import java.io.IOException;
//import java.io.InputStream;
//import java.util.List;
//
//@RestController
//@RequestMapping("/api/images")
//@AllArgsConstructor
//public class ProductImageController {
//
//
//    @Autowired
//    private final FileServiceImplementation fileService;
//    @Autowired
//    private final  ProductImageServiceImpl productImageService;
//
//
//    @PostMapping("/upload")
//    public ResponseEntity<ProductImageDTO> uploadProductImage(@RequestParam("file") MultipartFile file, @RequestParam("productId") Long productId) throws IOException {
//        ProductImageDTO productImage = productImageService.saveProductImage(file, productId);
//        return ResponseEntity.ok(productImage);
//    }
//
//    @GetMapping("/{imageName}")
//    public void downloadImage(@PathVariable("imageName") String imageName, HttpServletResponse response) throws IOException {
//        // Fetch the image as an InputStream from the fileService
//        InputStream resourceFile = fileService.getResourceFile("uploads", imageName);
//
//        // Set the content type based on the file extension
//        String contentType = getContentType(imageName);
//        response.setContentType(contentType);
//
//        // Copy the file data to the response output stream
//        StreamUtils.copy(resourceFile, response.getOutputStream());
//
//        // Ensure to flush the response output stream
//        response.flushBuffer();
//    }
//
//    private String getContentType(String fileName) {
//        if (fileName.endsWith(".jpg") || fileName.endsWith(".jpeg")) {
//            return MediaType.IMAGE_JPEG_VALUE;
//        } else if (fileName.endsWith(".png")) {
//            return MediaType.IMAGE_PNG_VALUE;
//        } else if (fileName.endsWith(".gif")) {
//            return MediaType.IMAGE_GIF_VALUE;
//        } else {
//            return MediaType.APPLICATION_OCTET_STREAM_VALUE;
//        }
//    }
//}


// File: ProductReviewController.java

//package com.backend.ecommerce.controllers;
//
//
//import com.backend.ecommerce.entity.ProductReview;
//import com.backend.ecommerce.implementation.ProductReviewServiceImplementation;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.http.HttpStatus;
//import org.springframework.http.ResponseEntity;
//import org.springframework.web.bind.annotation.PostMapping;
//import org.springframework.web.bind.annotation.RequestBody;
//import org.springframework.web.bind.annotation.RequestMapping;
//import org.springframework.web.bind.annotation.RestController;
//
//@RestController
//@RequestMapping("/api/product/review")
//public class ProductReviewController {
//
//    private final ProductReviewServiceImplementation productReviewServiceImplementation;
//
//    @Autowired
//    public ProductReviewController(ProductReviewServiceImplementation productReviewServiceImplementation) {
//        this.productReviewServiceImplementation = productReviewServiceImplementation;
//    }
//
//    @PostMapping
//    public ResponseEntity<ProductReview> addProductReview(@RequestBody ProductReview productReview) {
//        ProductReview createdProductReview = productReviewServiceImplementation.create(productReview);
//        return new ResponseEntity<>(createdProductReview, HttpStatus.CREATED);
//    }
//}


// File: S3Controller.java

package com.backend.ecommerce.controllers;

import com.backend.ecommerce.service.ImageUploader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@RestController
@RequestMapping("/api/s3")
public class S3Controller {

    private final ImageUploader uploader;

    @Autowired
    public S3Controller(ImageUploader uploader) {
        this.uploader = uploader;
    }

    @PostMapping
    public ResponseEntity<?> uploadImage(@RequestParam("file") MultipartFile file,
                                         @RequestParam("productId") Long productId) {
        return ResponseEntity.ok(uploader.uploadImage(file, productId));
    }

    @GetMapping
    public List<String> getAllImages() {
        return uploader.allImages();
    }

    @GetMapping("/{filename}")
    public String urlByName(@PathVariable String filename) {
        return uploader.getImageUrlByName(filename);
    }
}


// File: SizeController.java

package com.backend.ecommerce.controllers;

import com.backend.ecommerce.entity.Size;
import com.backend.ecommerce.implementation.SizeServiceImplementation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/sizes")
public class SizeController {
    @Autowired
    private SizeServiceImplementation sizeService;

    @PostMapping
    public Size createSize(@RequestBody Size size) {
        return sizeService.createSize(size);
    }

    @GetMapping
    public List<Size> getSizes() {
        return sizeService.getAllSizes();
    }
}


// File: TransactionController.java

package com.backend.ecommerce.controllers;

import com.backend.ecommerce.entity.Transaction;
import com.backend.ecommerce.service.TransactionService;
import lombok.AllArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/transactions")
@AllArgsConstructor
public class TransactionController {

    TransactionService transactionService;

    @PostMapping
    public ResponseEntity<Transaction> createTransaction(@RequestBody Transaction transaction) {
        Transaction transaction1 = transactionService.saveTransaction(transaction);
        return ResponseEntity.ok(transaction1);
    }

    @GetMapping
    public ResponseEntity<List<Transaction>> getAllTransactions() {
        List<Transaction> allTransactions = transactionService.getAllTransactions();
        return ResponseEntity.ok(allTransactions);
    }

    @GetMapping("/{id}")
    public ResponseEntity<Transaction> getTransactionById(@PathVariable Long id) {
        Transaction transaction = transactionService.getTransactionById(id);
        return ResponseEntity.ok(transaction);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Transaction> updateTransaction(@RequestBody Transaction transaction, @PathVariable Long id) {
        Transaction transaction1 = transactionService.updateTransaction(transaction, id);
        return ResponseEntity.ok(transaction1);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Transaction> deleteTransaction(@PathVariable Long id) {
        transactionService.deleteTransaction(id);
        return ResponseEntity.ok().build();
    }
}


// File: UserBankDetailsController.java

//package com.backend.ecommerce.controllers;
//
//import com.backend.ecommerce.entity.UserBankDetails;
//import com.backend.ecommerce.service.UserBankDetailsService;
//import lombok.AllArgsConstructor;
//import org.springframework.http.MediaType;
//import org.springframework.http.ResponseEntity;
//import org.springframework.web.bind.annotation.*;
//
//import java.util.List;
//import java.util.Optional;
//
//@RestController
//@RequestMapping("/api/addBankDetails")
//@AllArgsConstructor
//public class UserBankDetailsController {
//
//    private final UserBankDetailsService userBankDetailsService;
//
//    @GetMapping
//    public List<UserBankDetails> getAllBankDetails() {
//        return userBankDetailsService.getAllBankDetails();
//    }
//
//    @GetMapping("/{id}")
//    public ResponseEntity<UserBankDetails> getBankDetailsById(@PathVariable Long id) {
//        Optional<UserBankDetails> bankDetails = userBankDetailsService.getBankDetailsById(id);
//        return bankDetails.map(ResponseEntity::ok).orElseGet(() -> ResponseEntity.notFound().build());
//    }
//
//    @GetMapping("/user/{userId}")
//    public List<UserBankDetails> getBankDetailsByUserId(@PathVariable Long userId) {
//        return userBankDetailsService.getBankDetailsByUserId(userId);
//    }
//
//    @GetMapping("/primary/{isPrimary}")
//    public List<UserBankDetails> getPrimaryBankDetails(@PathVariable Boolean isPrimary) {
//        return userBankDetailsService.getPrimaryBankDetails(isPrimary);
//    }
//
//    @GetMapping("/status/{status}")
//    public List<UserBankDetails> getBankDetailsByStatus(@PathVariable String status) {
//        return userBankDetailsService.getBankDetailsByStatus(status);
//    }
//
//    @PostMapping("/{id}")
//    public UserBankDetails saveBankDetails(@PathVariable Long id, @RequestBody UserBankDetails bankDetails) {
//        return userBankDetailsService.saveBankDetails(id, bankDetails);
//    }
//
//    @DeleteMapping("/{id}")
//    public ResponseEntity<Void> deleteBankDetails(@PathVariable Long id) {
//        userBankDetailsService.deleteBankDetails(id);
//        return ResponseEntity.noContent().build();
//    }
//}


// File: UserController.java


package com.backend.ecommerce.controllers;

import com.backend.ecommerce.authentication.AuthenticationResponse;
import com.backend.ecommerce.entity.User;
import com.backend.ecommerce.implementation.UserServiceImplementation;
import com.backend.ecommerce.records.UserDTO;
import com.backend.ecommerce.repository.CartProductsRepository;
import com.backend.ecommerce.service.UserService;
import lombok.AllArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
@AllArgsConstructor
public class UserController {

    private final UserServiceImplementation userService;
    private final CartProductsRepository cartProductsRepository;

//    @PostMapping
//    public ResponseEntity<UserDTO> createUser(@RequestBody UserDTO userDTO) {
//        UserDTO user = userService.createUser(userDTO);
//        return ResponseEntity.ok(user);
//    }

    @PutMapping("/{id}")
    public ResponseEntity<UserDTO> updateUser(@PathVariable Long id, @RequestBody UserDTO userDTO) {
        UserDTO updatedUser = userService.updateUser(id, userDTO);
        return ResponseEntity.ok(updatedUser);
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserDTO> getUserById(@PathVariable Long id) {
        UserDTO userDTO = userService.getUserById(id);
        return ResponseEntity.ok(userDTO);
    }

    //TODO Late | Pagination | comment
    @GetMapping
    public ResponseEntity<List<UserDTO>> getAllUsers() {
        List<UserDTO> users = userService.getAllUsers();
        return ResponseEntity.ok(users);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUserById(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }

    //TODO comment
    @GetMapping("/email")
    public ResponseEntity<UserDTO> getUserByEmail(@RequestParam String email) {
        UserDTO userDTO = userService.getUserByEmail(email);
        return ResponseEntity.ok(userDTO);
    }


    @PostMapping("/signup")
    public String signup(@RequestBody User user) {
        System.out.println("Entered signup");
        userService.register(user);
        System.out.println("Going to UserServiceImplementation");
        return "token generated";
    }

    @PostMapping("/login")
    public String login(@RequestParam String email, @RequestParam String password) {
        return userService.login(email, password);
    }
}


// File: CartItemsDTO.java

package com.backend.ecommerce.dto;

import com.backend.ecommerce.entity.CartProducts;
import com.backend.ecommerce.entity.Product;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@AllArgsConstructor
@NoArgsConstructor
@Data
public class CartItemsDTO {

    Long cartItemId;
    Product product;
    String productName;
    Integer quantity;
    BigDecimal unitPrice;
    BigDecimal totalPrice;
    String imageUri;
    Boolean availability;
    LocalDateTime addedOn;
    String productApiEndpoint;

    public CartItemsDTO(CartProducts ci){
        Product p = ci.getProduct();
        this.cartItemId = ci.getId();
        this.product = ci.getProduct();
        this.productName = p.getName();
        this.unitPrice = p.getPrice();
        this.totalPrice = p.getPrice().multiply(BigDecimal.valueOf(ci.getQuantity()));
        this.quantity = ci.getQuantity();
        this.imageUri = null;
        this.availability = null; // TODO p.getAvailability();
        this.addedOn = null;
    }

}


// File: CheckoutRequest.java

package com.backend.ecommerce.dto;


import com.backend.ecommerce.entity.OrderProducts;
import com.backend.ecommerce.entity.Transaction;
import com.backend.ecommerce.entity.User;
import com.backend.ecommerce.enums.TransactionType;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;
import java.util.List;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
public class CheckoutRequest {

    private Long userId;
    private List<Long> orderProductsId;
    private TransactionType transactionType;
    private BigDecimal transactionAmount;
}


// File: EmailDetails.java

package com.backend.ecommerce.dto;


import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class EmailDetails {
    private String recipient;
    private String messageBody;
    private String subject;
    private String attachment;
}


// File: EmailResponse.java

package com.backend.ecommerce.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmailResponse {

    private String responseCode;
    private String responseMessage;
    private String accountInfo;
}


// File: OrderProductRequest.java

package com.backend.ecommerce.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class OrderProductRequest {
    private Long productId;
    private Integer quantity;
}


// File: OrderRequest.java

package com.backend.ecommerce.dto;

import lombok.*;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class OrderRequest {

    private Long userId;
    private List<OrderProductRequest> orderProducts = new ArrayList<>();
}


// File: ECommerceApplication.java

package com.backend.ecommerce;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ECommerceApplication {
	public static void main(String[] args) {
		SpringApplication.run(ECommerceApplication.class, args);
	}
}


// File: Address.java

package com.backend.ecommerce.entity;

import com.backend.ecommerce.enums.PhoneType;
import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.Data;

@Entity
@Data
public class Address {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String addressType;
    private String streetAddress;
    private String pinCode;

    @Enumerated(EnumType.STRING)
    private PhoneType phoneType;

    @ManyToOne(cascade = CascadeType.ALL, fetch =  FetchType.EAGER)
    @JsonBackReference
    private User user;

    @ManyToOne
    @JoinColumn(name = "city_id")
    private City city;

//    @ManyToOne(cascade = CascadeType.ALL)
//    @JsonIgnore
//    @JoinColumn(name = "buyer_id")
//    private Buyer buyer;
}


// File: Cart.java

package com.backend.ecommerce.entity;

import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Cart {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToOne
    @JsonBackReference
    private User user;

    @OneToMany(mappedBy = "cart", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonManagedReference
    private List<CartProducts> cartProducts = new ArrayList<>();

//    @ManyToOne
//    @JoinColumn(name = "buyer_id")
//    private Buyer buyer;


    @Override
    public String toString() {
        return "Cart{" +
                "id=" + id +
                ", user=" + user.getId() +
                ", cartProducts=" + " cartProducts value omitted " +
                '}';
    }
}


// File: CartProducts.java

package com.backend.ecommerce.entity;

import com.backend.ecommerce.enums.AvailabilityStatus;
import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
public class CartProducts {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "cart_id")
    @JsonBackReference
    private Cart cart;

    @OneToOne(cascade = CascadeType.ALL)
    private Product product;

    private Integer quantity;

    @Enumerated(EnumType.STRING)
    private AvailabilityStatus availabilityStatus;

    @Override
    public String toString() {
        return "CartProducts{" +
                "id=" + id +
                ", cart=" + "Cart Value Omitted" +
                ", product=" + product +
                ", quantity=" + quantity +
                '}';
    }
}


// File: Category.java

package com.backend.ecommerce.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.Data;

import java.util.ArrayList;
import java.util.List;

@Entity
@Data
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String description;

    @ManyToMany(mappedBy = "categories")
    @JsonIgnore
    private List<Product> products = new ArrayList<>();
}


// File: City.java

package com.backend.ecommerce.entity;


import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
public class City {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String city;
    private String state;
}


// File: Color.java

package com.backend.ecommerce.entity;

import jakarta.persistence.*;
import lombok.*;

import java.util.ArrayList;
import java.util.List;

@Entity
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class Color {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    @ManyToMany(mappedBy = "colors")
    private List<Product> products = new ArrayList<>();
}


// File: ForgotPassword.java

package com.backend.ecommerce.entity;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.springframework.security.web.csrf.CsrfTokenRepository;

import java.time.LocalDateTime;
import java.util.Date;

@Entity
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Builder
public class ForgotPassword {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private Integer otp;
    private Date expirationTime;

    @OneToOne
    @JsonBackReference
    private User user;
}


// File: Inventory.java

package com.backend.ecommerce.entity;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import lombok.*;

@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Getter
@Setter
public class Inventory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToOne
    @JoinColumn(name = "product_id")
    private Product product;

    private Integer quantity;
}


// File: Order.java

package com.backend.ecommerce.entity;


import com.backend.ecommerce.enums.AvailabilityStatus;
import com.backend.ecommerce.enums.OrderStatus;
import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@Table(name = "Orders")
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

//    private LocalDateTime orderDate;
//    private LocalDateTime updatedAt;

//    @Enumerated(EnumType.STRING)
//    private AvailabilityStatus availabilityStatus;

    @Enumerated(EnumType.STRING)
    private OrderStatus orderStatus;

    @OneToOne
    @JsonBackReference
    private User user;

    @OneToOne(mappedBy = "order", cascade = CascadeType.ALL)
    @JsonManagedReference
    private Transaction transaction;

    @OneToMany(cascade = CascadeType.ALL, mappedBy = "order")
    @JsonManagedReference
    private List<OrderProducts> orderProducts = new ArrayList<>();

//    @ManyToOne
//    private Buyer buyer;


    @CreationTimestamp
    @Column(name = "createdat", nullable = false)
    private LocalDateTime createdat;

    @UpdateTimestamp
    @Column(name = "modifiedat", nullable = false)
    private LocalDateTime modifiedate;

//    @Transient
//    private Long userId = user.getId();
//
//    @Transient
//    private Long transactionId = transaction.getId();
}


// File: OrderProducts.java

package com.backend.ecommerce.entity;


import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
public class OrderProducts {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToOne(cascade = CascadeType.ALL)
    private Product product;
    private Integer quantity;

    @ManyToOne
    @JoinColumn(name = "order_id")
    @JsonBackReference
    private Order order;
}


// File: Phone.java

package com.backend.ecommerce.entity;


import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
public class Phone {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    private Long phoneNumber;
}


// File: Product.java

package com.backend.ecommerce.entity;

import com.backend.ecommerce.enums.AvailabilityStatus;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String imageURL;
    private BigDecimal price;
    private String description;
    private String brand;
    private String returnPeriod;
    private Integer stockQuantity;
    private BigDecimal averageRating;
    private BigDecimal discountedPercentage;
    private BigDecimal currentPrice;
    private LocalDate deliveryDate;

    @CreationTimestamp
    private LocalDateTime dateAdded;
    @UpdateTimestamp
    private LocalDateTime dateUpdated;

    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    @JsonIgnore
    private List<Rating> rating = new ArrayList<>();

    @Enumerated(EnumType.STRING)
    private AvailabilityStatus availability;

    @ManyToMany
    @JoinTable(
            name = "product_sizes",
            joinColumns = @JoinColumn(name = "product_id"),
            inverseJoinColumns = @JoinColumn(name = "size_id")
    )
    private List<Size> sizes = new ArrayList<>();

    @ManyToMany
    @JoinTable(
            name = "product_colors",
            joinColumns = @JoinColumn(name = "product_id"),
            inverseJoinColumns = @JoinColumn(name = "color_id")
    )
    private List<Color> colors = new ArrayList<>();

    @ManyToMany
    @JoinTable(
            name = "product_category",
            joinColumns = @JoinColumn(name = "product_id"),
            inverseJoinColumns = @JoinColumn(name = "category_id")
    )
    @JsonIgnore
    private List<Category> categories = new ArrayList<>();

    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    private List<ProductImageTable> productImages = new ArrayList<>();

    @OneToOne(mappedBy = "product", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonIgnore
    private Inventory inventory;
}


// File: ProductImageTable.java

package com.backend.ecommerce.entity;


import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
public class ProductImageTable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "product_id")
    @JsonBackReference
    private Product product;

    private String imagePath;
}


// File: ProductReview.java

//package com.backend.ecommerce.entity;
//
//import jakarta.persistence.*;
//import lombok.*;
//import org.hibernate.annotations.CreationTimestamp;
//import org.springframework.data.util.Lazy;
//
//import java.time.LocalDateTime;
//import java.util.List;
//
//@Getter
//@Setter
//@AllArgsConstructor
//@NoArgsConstructor
//@Builder
//@Entity
//public class ProductReview {
//
//    @Id
//    @GeneratedValue(strategy = GenerationType.IDENTITY)
//    private int id;
//    private String comment;
//    private int rating;
//
//    @ManyToOne(fetch = FetchType.LAZY)
//    @JoinColumn(name = "user_id")
//    private User user;
//
//    @ManyToOne
//    @JoinColumn(name = "product_id")
//    private Product product;
//
//    @CreationTimestamp
//    private LocalDateTime reviewDate;
//}


// File: Rating.java

package com.backend.ecommerce.entity;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import lombok.*;

@Entity
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
public class Rating {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;
    private float stars;
    private float count;
    private String comment;

    @ManyToOne
    private Product product;

    @ManyToOne
    private User user;
}


// File: Size.java

package com.backend.ecommerce.entity;

import jakarta.persistence.*;
import lombok.*;

import java.util.ArrayList;
import java.util.List;

@Entity
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class Size {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    @ManyToMany(mappedBy = "sizes")
    private List<Product> products = new ArrayList<>();
}


// File: Transaction.java

package com.backend.ecommerce.entity;

import com.backend.ecommerce.enums.TransactionStatus;
import com.backend.ecommerce.enums.TransactionType;
import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Data
public class Transaction {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    private TransactionType transactionType;

    private TransactionStatus transactionStatus;

    private BigDecimal transactionAmount;

//    @ElementCollection
//    private List<String> productIds = new ArrayList<>();

    @CreationTimestamp
    @Column(name = "createdat", nullable = false)
    private LocalDateTime createdat;

    @UpdateTimestamp
    @Column(name = "modifiedat", nullable = false)
    private LocalDateTime modifiedat;

    @ManyToOne
    @JsonBackReference
    private User user;

    @OneToOne(cascade = CascadeType.ALL)
    @JsonBackReference
    private Order order;
}


// File: User.java

package com.backend.ecommerce.entity;

import com.backend.ecommerce.enums.Role;
import com.backend.ecommerce.exception.UserHasNoRoleException;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

@Entity
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
public class User implements UserDetails {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String firstName;
    private String lastName;
    private String googleId;
    private String email;
    private String password;
    private String username;
    private String securityQuestion;
    private String securityAnswer;
    private Long defaultPhoneNumber;

    @Enumerated(EnumType.STRING)
    @Builder.Default
    private Role role = Role.USER;

    @CreationTimestamp
    @Column(name = "createdat", nullable = false)
    private LocalDateTime createdat;

    @UpdateTimestamp
    @Column(name = "modifiedat")
    private LocalDateTime modifiedat;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    @JsonIgnore
    private List<Rating> ratings = new ArrayList<>();

    @OneToOne(cascade = CascadeType.ALL) //todo socho
    @JsonManagedReference
    private Order order;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    @JsonManagedReference
    private List<Address> addressList = new ArrayList<>();

    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonManagedReference
    private Cart cart;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.EAGER) // TODO getting error when change eager to lazy
    @JsonManagedReference
    private List<Transaction> transaction = new ArrayList<>();

    @OneToOne(mappedBy = "user")
    @JsonManagedReference
    private ForgotPassword forgotPassword;

//    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
//    private List<ProductReview> productReview;

    public User(String firstName, String lastName, String email, Long defaultPhoneNumber, List<Address> addressList) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.email = email;
        this.defaultPhoneNumber = defaultPhoneNumber;
        this.addressList = addressList;
    }

//    @Override
//    public String toString() {
//        return "User{" +
//                "id=" + id +
//                ", firstName='" + firstName + '\'' +
//                ", lastName='" + lastName + '\'' +
//                ", email='" + email + '\'' +
//                ", password='" + password + '\'' +
//                ", cart=" + (cart == null ? null : cart) +
//                '}';
//    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singleton(new SimpleGrantedAuthority("ROLE_" + role.name()));
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return email;
    }


    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }
}


// File: UserBankDetails.java

//package com.backend.ecommerce.entity;
//
//import com.fasterxml.jackson.annotation.JsonBackReference;
//import jakarta.persistence.*;
//import lombok.AllArgsConstructor;
//import lombok.Getter;
//import lombok.NoArgsConstructor;
//import lombok.Setter;
//import org.hibernate.annotations.CreationTimestamp;
//
//import java.time.LocalDateTime;
//
//@Entity
//@NoArgsConstructor
//@AllArgsConstructor
//@Getter
//@Setter
//public class UserBankDetails {
//
//    @Id
//    @GeneratedValue(strategy = GenerationType.IDENTITY)
//    private Long id;
//
//    @OneToOne
//    @JoinColumn(name = "user_id")
//    @JsonBackReference
//    private User user;
//
//    private String accountHolderName;
//    private String accountNumber;
//    private String bankName;
//    private String branchName;
//    private String ifscCode;
//    private String accountType;
//    private Boolean isPrimary;
//    private String status;
//
//    @CreationTimestamp
//    private LocalDateTime dateAdded;
//}


// File: AvailabilityStatus.java

package com.backend.ecommerce.enums;

public enum AvailabilityStatus {
    AVAILABLE,
    UNAVAILABLE,
    ;

    @Override
    public String toString() {
        return "AvailabilityStatus{}";
    }
}


// File: OrderStatus.java

package com.backend.ecommerce.enums;

public enum OrderStatus {
    PENDING,
    PROCESSING,
    SHIPPED,
    DELIVERED,
    CANCELED,
    RETURNED,
    CREATED;

    @Override
    public String toString() {
        return switch (this) {
            case PENDING -> "Pending";
            case PROCESSING -> "Processing";
            case SHIPPED -> "Shipped";
            case DELIVERED -> "Delivered";
            case CANCELED -> "Canceled";
            case RETURNED -> "Returned";
            case CREATED -> "Created";
            default -> throw new IllegalArgumentException();
        };
    }
}


// File: PhoneType.java

package com.backend.ecommerce.enums;

public enum PhoneType {
    LANDLINE,
    SMARTPHONE,
    HOME;
}


// File: Role.java

package com.backend.ecommerce.enums;

public enum Role {
    USER, ADMIN;
}


// File: TransactionStatus.java

package com.backend.ecommerce.enums;

public enum TransactionStatus {
    PENDING,
    COMPLETED,
    PROCESSING,
    REFUNDED,
    CANCELLED
}


// File: TransactionType.java

package com.backend.ecommerce.enums;

public enum TransactionType {

    IMPS,
    UPI,
    COD,
    DEBIT_CARD,
    CREDIT_CARD, BANK;


    @Override
    public String toString() {
        return switch (this) {
            case COD -> "COD";
            case IMPS -> "IMPS";
            case UPI -> "UPI";
            case DEBIT_CARD -> "DEBIT_CARD";
            case CREDIT_CARD -> "CREDIT_CARD";
            default -> throw new IllegalArgumentException();
        };
    }
}


// File: CategoryNotFoundException.java

package com.backend.ecommerce.exception;

public class CategoryNotFoundException extends RuntimeException {
    public CategoryNotFoundException(String message) {
        super(message);
    }
}


// File: DuplicateEntryException.java

package com.backend.ecommerce.exception;

public class DuplicateEntryException extends RuntimeException {
    public DuplicateEntryException(String string) {
        super("Duplicate Entry Found in the Database for " + string);
    }
    public DuplicateEntryException(String string, Long id) {
        super("Duplicate Entry Found in the Database for " + string + " " + id);
    }
}


// File: FIleExistsException.java

package com.backend.ecommerce.exception;

public class FIleExistsException extends RuntimeException {

    public FIleExistsException(String message) {
        super(message);
    }
}


// File: GlobalExceptionHandler.java

package com.backend.ecommerce.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ProblemDetail;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ProductNotFoundException.class)
    public ProblemDetail handleProductNotFoundException(ProductNotFoundException ex) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.NOT_FOUND, ex.getMessage());
    }

    @ExceptionHandler(CategoryNotFoundException.class)
    public ProblemDetail handleCategoryNotFoundException(Exception ex) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.INTERNAL_SERVER_ERROR, ex.getMessage());
    }

    @ExceptionHandler(DuplicateEntryException.class)
    public ProblemDetail handleDuplicateEntryException(Exception ex) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.INTERNAL_SERVER_ERROR, ex.getMessage());
    }

    @ExceptionHandler(UserNotFoundException.class)
    public ProblemDetail handleUserNotFoundException(Exception ex) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.NOT_FOUND, ex.getMessage());
    }

    @ExceptionHandler(UserHasNoRoleException.class)
    public ProblemDetail handleUserHasNoRoleException(Exception exception) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.NOT_FOUND, exception.getMessage());
    }

    @ExceptionHandler(PasswordDidNotMatchException.class)
    public ProblemDetail handlePasswordDidNotMatch(Exception exception) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.BAD_REQUEST, exception.getMessage());
    }

    @ExceptionHandler(InventoryNotFoundException.class)
    public ProblemDetail handleInventoryNotFoundException(Exception exception) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.NOT_FOUND, exception.getMessage());
    }

    @ExceptionHandler(InsufficientStockException.class)
    public ProblemDetail handleInsufficientStockException(Exception exception) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.NOT_FOUND, exception.getMessage());
    }

    @ExceptionHandler(ProductReviewNotFoundException.class)
    public ProblemDetail handleProductReviewNotFoundException(Exception exception) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.NOT_FOUND, exception.getMessage());
    }

    @ExceptionHandler(ImageUploadException.class)
    public ProblemDetail handleImageUploadException(Exception exception) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.INTERNAL_SERVER_ERROR, exception.getMessage());
    }
}


// File: ImageUploadException.java

package com.backend.ecommerce.exception;

import java.io.IOException;

public class ImageUploadException extends RuntimeException {
    public ImageUploadException(String message) {
        super(message);
    }
}


// File: InsufficientStockException.java

package com.backend.ecommerce.exception;

public class InsufficientStockException extends Throwable {
    public InsufficientStockException(String message) {
        super(message);
    }
}


// File: InventoryNotFoundException.java

package com.backend.ecommerce.exception;

public class InventoryNotFoundException extends Throwable {
    public InventoryNotFoundException(String s) {
        super(s);
    }
}


// File: PasswordDidNotMatchException.java

package com.backend.ecommerce.exception;

import org.springframework.http.ProblemDetail;

public class PasswordDidNotMatchException extends RuntimeException {
    public PasswordDidNotMatchException(String message) {
        super(message);
    }
}


// File: ProductNotFoundException.java

package com.backend.ecommerce.exception;

public class ProductNotFoundException extends RuntimeException {
    public ProductNotFoundException(String message) {
        super(message);
    }
}


// File: ProductReviewNotFoundException.java

package com.backend.ecommerce.exception;

public class ProductReviewNotFoundException extends RuntimeException {
    public ProductReviewNotFoundException(String s) {
        super(s);
    }
}


// File: ResourceNotFoundException.java

package com.backend.ecommerce.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}


// File: UserHasNoRoleException.java

package com.backend.ecommerce.exception;

public class UserHasNoRoleException extends Throwable {
    public UserHasNoRoleException(String message) {
        super(message);
    }
}


// File: UserNotFoundException.java

package com.backend.ecommerce.exception;

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}


// File: AddressServiceImplementation.java

package com.backend.ecommerce.implementation;

import com.backend.ecommerce.mapper.UserMapper;
import com.backend.ecommerce.entity.Address;
import com.backend.ecommerce.entity.User;
import com.backend.ecommerce.exception.ResourceNotFoundException;
import com.backend.ecommerce.repository.AddressRepository;
import com.backend.ecommerce.repository.UserRepository;
import com.backend.ecommerce.service.AddressService;
import com.backend.ecommerce.service.UserService;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
@AllArgsConstructor
public class AddressServiceImplementation implements AddressService {

    private final AddressRepository addressRepository;
    private final UserService userService;
    private final UserMapper customModelMapper;
    private final UserRepository userRepository;

    @Override
    public Address save(Long userId, Address address) {
        User user = userRepository.findById(userId).get();
        user.getAddressList().add(address);
        address.setUser(user);
        return addressRepository.save(address);
    }

    @Override
    public List<Address> getAll() {
        return addressRepository.findAll();
    }

    @Override
    public Address updateAddressByUserId(Address address, Long userId) {
        // Fetch the user by ID
        User user = customModelMapper.reverse(userService.getUserById(userId));

        // Check if the user exists
        if (user != null) {
            // Fetch the address associated with the user
            Optional<Address> userAddressOptional = addressRepository.findByUserId(userId);

            if (userAddressOptional.isPresent()) {
                Address existingAddress = AddressService.getAddress(address, userAddressOptional);

                // Save the updated address
                return addressRepository.save(existingAddress);
            } else {
                // If the user does not have an address yet, create a new one
                address.setUser(user);
                return addressRepository.save(address);
            }
        } else {
            throw new IllegalArgumentException("User with ID " + userId + " does not exist");
        }
    }

    @Override
    public Address getAddressByUserId(Long id) {
        User user = userRepository.findById(id).orElseThrow(() -> new ResourceNotFoundException("User not found with this id: " + id));
        return addressRepository.findByUserId(user.getId()).orElseThrow(() -> new ResourceNotFoundException("User not found with this id: " + id));
    }

    @Override
    public String deleteAddressById(Long id) {
        addressRepository.deleteById(id);
        return "Adress deleted";
    }
}


// File: AuthenticationService.java

package com.backend.ecommerce.implementation;

import com.backend.ecommerce.authentication.AuthenticationRequest;
import com.backend.ecommerce.authentication.AuthenticationResponse;
import com.backend.ecommerce.authentication.RegisterRequest;
import com.backend.ecommerce.mapper.UserMapper;
import com.backend.ecommerce.dto.EmailDetails;
import com.backend.ecommerce.entity.User;
import com.backend.ecommerce.enums.Role;
import com.backend.ecommerce.exception.DuplicateEntryException;
import com.backend.ecommerce.records.UserDTO;
import com.backend.ecommerce.repository.UserRepository;
import com.backend.ecommerce.security.JWTService;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AuthenticationService {

    private final UserRepository userRepository;
    private final JWTService jwtService;
    private final AuthenticationManager authenticationManager;
    private final UserMapper customModelMapper;
    private final EmailServiceImplementation emailService;
    private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    public AuthenticationResponse register(RegisterRequest request) {

        // Check if mail already exists
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new DuplicateEntryException("Email already exists");
        }

        var user = User.builder()
                .firstName(request.getFirstName())
                .lastName(request.getLastName())
                .email(request.getEmail())
                .password(passwordEncoder.encode(request.getPassword()))
                .role(Role.USER)
                .build();

        User savedUser = userRepository.save(user);

        // Send email notification to the user
        EmailDetails emailDetails = EmailDetails.builder()
                .recipient(savedUser.getEmail())
                .subject("Account Creation")
                .messageBody("Congratulations! You have successfully created your account!")
                .build();
        emailService.sendEmailAlert(emailDetails);

        // Generate JWT token
        String token = jwtService.generateToken(savedUser.getEmail(), savedUser.getRole().name());

        UserDTO userDTO = customModelMapper.apply(savedUser);
        AuthenticationResponse authenticationResponse = new AuthenticationResponse();
        authenticationResponse.setToken(token);
        authenticationResponse.setUserDTO(userDTO);
        System.out.println("Token: " + token);
        System.out.println("User: " + userDTO);
        return authenticationResponse;
    }

    public AuthenticationResponse authenticate(AuthenticationRequest request) {
        doAuthenticate(request.getEmail(), request.getPassword());
        var user = userRepository.findByEmail(request.getEmail()).orElseThrow(() -> new DuplicateEntryException("Email already exists"));
        var jwtToken = jwtService.generateToken(user.getEmail(), user.getRole().name());
        return AuthenticationResponse.builder().token(jwtToken)
                .userDTO(customModelMapper.apply(user)) // convert user into userDTO
                .build();
    }

    private void doAuthenticate(String email, String password) {
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(email, password);
        try {
            authenticationManager.authenticate(authentication);
        } catch (BadCredentialsException e) {
            throw new BadCredentialsException("Invalid Password");
        }
    }
}


// File: CartServiceImplementation.java

package com.backend.ecommerce.implementation;

import com.backend.ecommerce.exception.InsufficientStockException;
import com.backend.ecommerce.exception.InventoryNotFoundException;
import com.backend.ecommerce.records.CartDTO;
import com.backend.ecommerce.entity.*;
import com.backend.ecommerce.repository.CartProductsRepository;
import com.backend.ecommerce.repository.CartRepository;
import com.backend.ecommerce.repository.ProductRepository;
import com.backend.ecommerce.repository.UserRepository;
import com.backend.ecommerce.dto.CartItemsDTO;
import com.backend.ecommerce.service.CartService;
import com.backend.ecommerce.service.InventoryService;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
@AllArgsConstructor
@Slf4j
public class CartServiceImplementation implements CartService {

    private UserRepository userRepository;
    private CartRepository cartRepository;
    private ProductRepository productRepository;
    private CartProductsRepository cartProductsRepository;
    private final InventoryService inventoryService;

    /** The following code either creates a new cart with new cartItem
     * or creates a new cartItem in the cart, if product was not already in the cart
     * or updates the quantity of the product if it was already present in the cart
     **/

//    @Override
//    public CartProducts addProductToCart(Long userId, Long productId, Integer quantity) {
//        User user = userRepository.findById(userId).orElseThrow(() -> new RuntimeException("User not found"));
//        Product product = productRepository.findById(productId).orElseThrow(() -> new RuntimeException("Product not found"));
//
//
//        Cart cart = user.getCart();
//
//        CartProducts cartProducts;
//
//        //FLOWCHART
//        //                                                       /---- Exists ---> Update Its
//        //                /--> Exists --------> product exists? {                   Quantity --->\
//        //               /                                       \                                \
//        // cart exists? {                                   Doesn't exist                          X ->Save Cart
//        //               \                                         \                              /
//        //                \--> Doesn't exist -> ----------------------> Create New item  ------->/
//        //                                                                & add to cart
//
//        Optional<CartProducts> existingCartItemOpt = Optional.empty();
//
//        //if Cart is present then try finding if the product being added is already in the cart or not
//        if(!Objects.isNull(cart)) {
//            existingCartItemOpt = cartProductsRepository.findByCartIdAndProductId(cart.getId(), productId);
//        }
//        //if cart is not present then create new cart
//        else{
//            cart = new Cart();
//            cart.setUser(user);
//        }
//
//        //if product is present then change its quantity to new one
//        if (existingCartItemOpt.isPresent()) {
//            cartProducts = existingCartItemOpt.get();
//            cartProducts.setQuantity(quantity);
//        }
//        //if product is not present, or it's a new cart then create new item
//        else {
//            cartProducts = new CartProducts();
//            cartProducts.setCart(cart);
//            cartProducts.setProduct(product);
//            cartProducts.setQuantity(quantity);
//        }
//
//        return cartProductsRepository.save(cartProducts);
//    }

    @Override
    public CartProducts addProductToCart(Long userId, Long productId, Integer quantity) {
        User user = userRepository.findById(userId).orElseThrow(() -> new RuntimeException("User not found"));
        Product product = productRepository.findById(productId).orElseThrow(() -> new RuntimeException("Product not found"));

        Cart cart = user.getCart();
        CartProducts cartProducts;

        Optional<CartProducts> existingCartItemOpt = Optional.empty();

        // Check if the cart exists
        if (cart != null) {
            existingCartItemOpt = cartProductsRepository.findByCartIdAndProductId(cart.getId(), productId);
        } else {
            // Create a new cart if it doesn't exist
            cart = new Cart();
            cart.setUser(user);
        }

        // If the product already exists in the cart, update the quantity
        if (existingCartItemOpt.isPresent()) {
            cartProducts = existingCartItemOpt.get();
            int newQuantity = cartProducts.getQuantity() + quantity;
            cartProducts.setQuantity(newQuantity);
        } else {
            // If the product is not in the cart, create a new cart item
            cartProducts = new CartProducts();
            cartProducts.setCart(cart);
            cartProducts.setProduct(product);
            cartProducts.setQuantity(quantity);
        }

        // Decrease stock
        try {
            inventoryService.decreaseStock(productId, quantity);
        } catch (InsufficientStockException | InventoryNotFoundException e) {
            throw new RuntimeException(e);
        }

        return cartProductsRepository.save(cartProducts);
    }

    @Override // TODO create controller for this
    public void removeProductFromCart(Long userId, Long productId, Integer quantity) {
        User user = userRepository.findById(userId).orElseThrow(() -> new RuntimeException("User not found"));
        Cart cart = user.getCart();

        if (cart == null) {
            throw new RuntimeException("Cart not found");
        }

        CartProducts cartProducts = cartProductsRepository.findByCartIdAndProductId(cart.getId(), productId)
                .orElseThrow(() -> new RuntimeException("Product not found in cart"));

        int newQuantity = cartProducts.getQuantity() - quantity;

        if (newQuantity <= 0) {
            cartProductsRepository.delete(cartProducts);
        } else {
            cartProducts.setQuantity(newQuantity);
            cartProductsRepository.save(cartProducts);
        }

        // Increase stock
        try {
            inventoryService.increaseStock(productId, quantity);
        } catch (InventoryNotFoundException e) {
            throw new RuntimeException(e);
        }
    }


    @Override
    public List<Cart> getAllCarts() {
        return cartRepository.findAll();
    }

    @Override
    public Cart getCart(Long cartId) {
        return cartRepository.findById(cartId).get();
    }

    @Override
    public List<CartItemsDTO> getCartItemsByUserId(Long userId) {
        Optional<Cart> cartOpt = cartRepository.findByUserId(userId);
        if(cartOpt.isEmpty()) {
            throw new RuntimeException("Not Present");
        }
        Long cartId = cartOpt.get().getId();
        List<CartProducts> cartProductsList = cartProductsRepository.findAllByCartId(cartId);
        return cartProductsList.stream()
                .map(CartItemsDTO::new).toList();
    }

    @Override
    public CartDTO getCartByUserId(Long userId) { // TODO when creating new user the new user gets the old cart fix this
        Optional<Cart> cartOpt = cartRepository.findByUserId(userId);
            if(cartOpt.isEmpty()) {
                throw new RuntimeException("Not Present");
            } else {
                return convertToDTO(cartOpt.get());
            }
        }

}


// File: CategoryServiceImplementation.java

package com.backend.ecommerce.implementation;


import com.backend.ecommerce.entity.Category;
import com.backend.ecommerce.entity.Product;
import com.backend.ecommerce.mapper.CategoryMapper;
import com.backend.ecommerce.records.CategoryDTO;
import com.backend.ecommerce.repository.CategoryRepository;
import com.backend.ecommerce.repository.ProductRepository;
import com.backend.ecommerce.service.CategoryService;
import lombok.AllArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

@Service
public class CategoryServiceImplementation implements CategoryService {

    private final ProductRepository productRepository;
    private final CategoryRepository categoryRepository;
    private final CategoryMapper categoryMapper;

    @Autowired
    public CategoryServiceImplementation(ProductRepository productRepository, CategoryRepository categoryRepository, CategoryMapper categoryMapper) {
        this.productRepository = productRepository;
        this.categoryRepository = categoryRepository;
        this.categoryMapper = categoryMapper;
    }


    @Override
    public List<CategoryDTO> findAll() {
        List<Category> categoryList = categoryRepository.findAll();
        return categoryList.stream().map((categoryMapper::apply)).toList();
    }

    @Override
    public CategoryDTO findById(Long id) {
        Category category = categoryRepository.findById(id).orElseThrow(() -> new RuntimeException("Category not found with this id"));
        return categoryMapper.apply(category);
    }

    @Override
    public List<CategoryDTO> getCategoryByProductId(Long productId) {
        Product product = productRepository.findById(productId).orElseThrow(() -> new RuntimeException("Product not found with this id"));
//        return new ArrayList<>(product.getCategory());
        return null;
    }

    @Override
    public CategoryDTO create(Category category) {
        Category savedCategory = categoryRepository.save(category);
        return categoryMapper.apply(savedCategory);
    }

    @Override
    public String delete(Long id) {
        categoryRepository.deleteById(id);
        return "Category deleted successfully";
    }

    @Override
    public CategoryDTO update(Category category, Long id) {
        Category existingCategory = categoryRepository.findById(id).orElseThrow(() -> new RuntimeException("User not found with this id"));
        existingCategory.setName(category.getName());
        existingCategory.setDescription(category.getDescription());
        existingCategory.setProducts(category.getProducts());
        Category savedCategory = categoryRepository.save(existingCategory);
        return categoryMapper.apply(savedCategory);
    }

    @Override
    public List<CategoryDTO> createListOfCategory(List<Category> categoryList) {
        List<Category> categories = categoryRepository.saveAll(categoryList);
        return categories.stream().map((categoryMapper::apply)).toList();
    }
}


// File: ColorServiceImplementation.java

package com.backend.ecommerce.implementation;

import com.backend.ecommerce.entity.Color;
import com.backend.ecommerce.repository.ColorRepository;
import com.backend.ecommerce.service.ColorService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class ColorServiceImplementation implements ColorService {
    @Autowired
    private ColorRepository colorRepository;

    public Color createColor(Color color) {
        return colorRepository.save(color);
    }

    public List<Color> getAllColors() {
        return colorRepository.findAll();
    }
}


// File: EmailServiceImplementation.java

package com.backend.ecommerce.implementation;

import com.backend.ecommerce.dto.EmailDetails;
import com.backend.ecommerce.repository.EmailService;
import lombok.AllArgsConstructor;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class EmailServiceImplementation implements EmailService {

    private final JavaMailSender mailSender;

    @Value("${spring.mail.username}")
    private String senderEmailAddress;


    @Override
    public void sendEmailAlert(EmailDetails emailDetails) {
        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(senderEmailAddress);
            message.setTo(emailDetails.getRecipient());
            message.setText(emailDetails.getMessageBody());
            message.setSubject(emailDetails.getSubject());

            mailSender.send(message);
            System.out.println("mail sent");
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}


// File: FileServiceImplementation.java

//package com.backend.ecommerce.implementation;
//
//import com.backend.ecommerce.service.FileService;
//import org.springframework.stereotype.Service;
//import org.springframework.web.multipart.MultipartFile;
//
//import java.io.*;
//import java.nio.file.Files;
//import java.nio.file.Paths;
//import java.nio.file.StandardCopyOption;
//import java.util.UUID;
//
//@Service
//public class FileServiceImplementation implements FileService {
//
//    @Override
//    public String uploadFile(String path, MultipartFile file) throws IOException {
//        // get name of the file
//        String originalFilename = file.getOriginalFilename();
//
//        // generating random name pic
//        String randomID = UUID.randomUUID().toString();
//        String fileName1 = randomID.concat(originalFilename.substring(originalFilename.lastIndexOf(".")));
//
//        // get the file Path
//        String filePath = path + File.separator + fileName1;
//
//        // crete file object
//        File f = new File(path);
//        if (!f.exists()) {
//            f.mkdir();
//        }
//
//        // copy the file or upload the file to the path
//        Files.copy(file.getInputStream(), Paths.get(filePath), StandardCopyOption.REPLACE_EXISTING);
//        return fileName1;
//    }
//
//    @Override
//    public InputStream getResourceFile(String path, String fileName) throws FileNotFoundException {
//        String filePath = path + File.separator + fileName;
//        return new FileInputStream(filePath);
//    }
//}


// File: ForgotPasswordServiceImplementation.java

package com.backend.ecommerce.implementation;

import com.backend.ecommerce.dto.EmailDetails;
import com.backend.ecommerce.entity.ForgotPassword;
import com.backend.ecommerce.entity.User;
import com.backend.ecommerce.exception.PasswordDidNotMatchException;
import com.backend.ecommerce.exception.UserNotFoundException;
import com.backend.ecommerce.repository.EmailService;
import com.backend.ecommerce.repository.ForgotPasswordRepository;
import com.backend.ecommerce.repository.UserRepository;
import com.backend.ecommerce.service.ForgotPasswordService;
import com.backend.ecommerce.records.ChangePassword;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.Date;
import java.util.Objects;
import java.util.Random;

@Service
public class ForgotPasswordServiceImplementation implements ForgotPasswordService {

    private final EmailService emailService;
    private final UserRepository userRepository;
    private final ForgotPasswordRepository forgotPasswordRepository;
    private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    @Autowired
    public ForgotPasswordServiceImplementation(EmailService emailService, UserRepository userRepository, ForgotPasswordRepository forgotPasswordRepository ) {
        this.emailService = emailService;
        this.userRepository = userRepository;
        this.forgotPasswordRepository = forgotPasswordRepository;
    }

    @Override
    public String verifyEmail(String email) {
        User user = userRepository.findByEmail(email).orElseThrow(() -> new UserNotFoundException("User not found in the database with this email id: " + email));
        int otp = generateOTP();
        EmailDetails emailDetails = EmailDetails.builder()
                .recipient(email)
                .messageBody("This is the OTP for your Forgot Password request :" + otp)
                .subject("OTP for forgot password request")
                .build();

        ForgotPassword forgotPassword = ForgotPassword.builder()
                .otp(otp)
                .expirationTime(new Date(System.currentTimeMillis() + 10 * 60 * 1000))
                .user(user)
                .build();

        emailService.sendEmailAlert(emailDetails);
        forgotPasswordRepository.save(forgotPassword);
        return "Email sent for verification";
    }

    @Override
    public String verifyOTP(Integer otp, String email) {
        User user = userRepository.findByEmail(email).orElseThrow(() -> new UserNotFoundException("User not found in the database with this email id: " + email));
        ForgotPassword forgotPassword = forgotPasswordRepository.findByOtpAndUser(otp, user).orElseThrow(() -> new RuntimeException("Invalid OTP for email : " + email));

        if (forgotPassword.getExpirationTime().before(Date.from(Instant.now()))) {
            forgotPasswordRepository.deleteById(forgotPassword.getId());
            return "OTP has expired";
        }
        return "OTP verified";
    }

    @Override
    public String changePasswordHandler(ChangePassword changePassword, String email) {
        if (!Objects.equals(changePassword.password(), changePassword.repeatPassword())) {
            throw new PasswordDidNotMatchException("The entered password is not matching ");
        }
        String encodedPassword = passwordEncoder.encode(changePassword.password());
        userRepository.updatePassword(email, encodedPassword);

        emailService.sendEmailAlert(EmailDetails.builder()
                        .subject("Password Changed")
                        .messageBody("Your password has successfully been changed")
                        .recipient(email)
                .build());
        return "Password has been changed";
    }

    private Integer generateOTP() {
        Random random = new Random();
        return random.nextInt(100000, 999999);
    }
}


// File: InventoryServiceImplementation.java

package com.backend.ecommerce.implementation;

import com.backend.ecommerce.entity.Inventory;
import com.backend.ecommerce.entity.Product;
import com.backend.ecommerce.exception.InsufficientStockException;
import com.backend.ecommerce.exception.InventoryNotFoundException;
import com.backend.ecommerce.exception.ProductNotFoundException;
import com.backend.ecommerce.exception.ResourceNotFoundException;
import com.backend.ecommerce.mapper.InventoryMapper;
import com.backend.ecommerce.records.InventoryDTO;
import com.backend.ecommerce.repository.InventoryRepository;
import com.backend.ecommerce.repository.ProductRepository;
import com.backend.ecommerce.service.InventoryService;
import lombok.AllArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.Optional;

@Service
public class InventoryServiceImplementation implements InventoryService {

    private final ProductRepository productRepository;
    private final InventoryRepository inventoryRepository;
    private final InventoryMapper inventoryMapper;

    @Autowired
    public InventoryServiceImplementation(ProductRepository productRepository, InventoryRepository inventoryRepository, InventoryMapper inventoryMapper) {
        this.productRepository = productRepository;
        this.inventoryRepository = inventoryRepository;
        this.inventoryMapper = inventoryMapper;
    }


    @Override
    public InventoryDTO addInventory(Long productId, Integer stock) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new ProductNotFoundException("Product not found with this id:" + productId));
        Inventory inventory = new Inventory();
        inventory.setProduct(product);
        inventory.setQuantity(stock);
        Inventory savedInventory = inventoryRepository.save(inventory);
        return inventoryMapper.apply(savedInventory);
    }

    @Override
    public InventoryDTO updateStock(Long productId, Integer stock) {
        Inventory inventory = inventoryRepository.findByProduct(productRepository.findById(productId)
                        .orElseThrow(() -> new ResourceNotFoundException("Product not found")))
                .orElseThrow(() -> new ResourceNotFoundException("Inventory not found"));
        inventory.setQuantity(stock);
        Inventory save = inventoryRepository.save(inventory);
        return inventoryMapper.apply(save);
    }

    @Override
    public InventoryDTO getInventoryByProduct(Long productId) throws InventoryNotFoundException {
        Product product = productRepository.findById(productId).orElseThrow(() -> new ProductNotFoundException("Product not found with this id: " + productId));
        Optional<Inventory> byProduct = inventoryRepository.findByProduct(product);
        if (byProduct.isEmpty()) {
            throw new InventoryNotFoundException("Inventory not found with this product");
        }
        Inventory inventory = byProduct.get();
        return inventoryMapper.apply(inventory);
    }

    @Override
    public List<InventoryDTO> getAllInventory() {
        List<Inventory> inventoryList = inventoryRepository.findAll();
        return inventoryList.stream().map(inventoryMapper::apply).toList();
    }

    @Override
    public InventoryDTO increaseStock(Long productId, Integer quantity) throws InventoryNotFoundException {
        Inventory inventory = inventoryRepository.findByProduct(productRepository.findById(productId)
                        .orElseThrow(() -> new ProductNotFoundException("Product not found with this id: " + productId)))
                .orElseThrow(() -> new InventoryNotFoundException("Inventory not found"));

        inventory.setQuantity(inventory.getQuantity() + quantity);
        Inventory save = inventoryRepository.save(inventory);
        return inventoryMapper.apply(save);
    }

    @Override
    public InventoryDTO decreaseStock(Long productId, Integer quantity) throws InsufficientStockException, InventoryNotFoundException {
        Inventory inventory = inventoryRepository.findByProduct(productRepository.findById(productId)
                        .orElseThrow(() -> new ProductNotFoundException("Product not found with this id: " + productId)))
                .orElseThrow(() -> new InventoryNotFoundException("Inventory not found"));

        if (inventory.getQuantity() < quantity) {
            throw new InsufficientStockException("Not enough stock available");
        }
        inventory.setQuantity(inventory.getQuantity() - quantity);
        Inventory save = inventoryRepository.save(inventory);
        return inventoryMapper.apply(save);
    }

    @Override
    public Boolean isStockAvailable(Long productId, Integer quantity) throws InventoryNotFoundException {
        Inventory inventory = inventoryRepository.findByProduct(productRepository.findById(productId)
                        .orElseThrow(() -> new ProductNotFoundException("Product not found with this id: " + productId)))
                .orElseThrow(() -> new InventoryNotFoundException("Inventory not found"));

        return inventory.getQuantity() >= quantity;
    }

    @Override
    public void bulkUpdateStock(Map<Long, Integer> stockUpdates) throws InventoryNotFoundException {
        for (Map.Entry<Long, Integer> entry : stockUpdates.entrySet()) {
            Long productId = entry.getKey();
            Integer stock = entry.getValue();

            Inventory inventory = inventoryRepository.findByProduct(productRepository.findById(productId)
                            .orElseThrow(() -> new ProductNotFoundException("Product not found with this id: " + productId)))
                    .orElseThrow(() -> new InventoryNotFoundException("Inventory not found"));

            inventory.setQuantity(stock);
            inventoryRepository.save(inventory);
        }
    }
}


// File: OrderServiceImplementation.java

package com.backend.ecommerce.implementation;

import com.backend.ecommerce.dto.OrderProductRequest;
import com.backend.ecommerce.dto.OrderRequest;
import com.backend.ecommerce.entity.*;
import com.backend.ecommerce.enums.OrderStatus;
import com.backend.ecommerce.enums.TransactionStatus;
import com.backend.ecommerce.enums.TransactionType;
import com.backend.ecommerce.repository.*;
import com.backend.ecommerce.service.OrderService;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;
import java.util.stream.Collectors;

@Service
@AllArgsConstructor
@Transactional
public class OrderServiceImplementation implements OrderService {

    private final OrderRepository orderRepository;
    private final TransactionRepository transactionRepository;
    private final UserRepository userRepository;
    private final ProductRepository productRepository;
    private final OrderProductsRepository orderProductsRepository;
    private final CartRepository cartRepository;


    @Override
    public void createOrder(OrderRequest orderRequest) {
        // Retrieve user
        User user = userRepository.findById(orderRequest.getUserId()).orElseThrow(() -> new RuntimeException("User not found"));

        // Create Order entity
        Order order = new Order();
        order.setUser(user);
        order.setOrderStatus(OrderStatus.PENDING);

        // Save order to get its ID
        order = orderRepository.save(order);

        // Create OrderProducts entities and establish mappings
        for (OrderProductRequest productRequest : orderRequest.getOrderProducts()) {
            Product product = productRepository.findById(productRequest.getProductId()).orElseThrow(() -> new RuntimeException("Product not found"));

            // Create OrderProduct entity
            OrderProducts orderProducts = new OrderProducts();
            orderProducts.setOrder(order);
            orderProducts.setProduct(product);
            orderProducts.setQuantity(productRequest.getQuantity());

            // Save OrderProducts entity
            orderProductsRepository.save(orderProducts);

            // Add OrderProducts entity to order's list of order Products
            order.getOrderProducts().add(orderProducts);
        }

        // update the order
        orderRepository.save(order);
    }


    @Override
    public Order getOrder(Integer id) {
        return orderRepository.findById(id).orElseThrow(() -> new RuntimeException("Order not found"));
    }

    @Override
    public List<Order> getAllOrders() {
        return orderRepository.findAll();
    }

    @Override
    public Order convertCartToOrder(Long cartId) {
        Cart cart = cartRepository.findById(cartId).orElseThrow(() -> new RuntimeException("Cart not found"));
        User user = cart.getUser();

        Order order = new Order();
        order.setUser(user);

        List<OrderProducts> orderProductsList = cart.getCartProducts().stream().map(cartProduct -> {
            OrderProducts orderProduct = new OrderProducts();
            orderProduct.setOrder(order);
            orderProduct.setProduct(cartProduct.getProduct());
            orderProduct.setQuantity(cartProduct.getQuantity());
            return orderProduct;
        }).collect(Collectors.toList());

        order.setOrderProducts(orderProductsList);

        return orderRepository.save(order);
    }
}


// File: ProductImageServiceImpl.java

//package com.backend.ecommerce.implementation;
//
//import com.backend.ecommerce.entity.Product;
//import com.backend.ecommerce.entity.ProductImageTable;
//import com.backend.ecommerce.mapper.ProductImageMapper;
//import com.backend.ecommerce.records.ProductImageDTO;
//import com.backend.ecommerce.repository.ProductImageRepository;
//import com.backend.ecommerce.repository.ProductRepository;
//import com.backend.ecommerce.service.FileService;
//import com.backend.ecommerce.service.ProductImageService;
//import jakarta.servlet.http.HttpServletResponse;
//import lombok.AllArgsConstructor;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.beans.factory.annotation.Value;
//import org.springframework.http.MediaType;
//import org.springframework.stereotype.Service;
//import org.springframework.util.StreamUtils;
//import org.springframework.web.bind.annotation.PathVariable;
//import org.springframework.web.multipart.MultipartFile;
//
//import java.io.IOException;
//import java.io.InputStream;
//import java.util.List;
//
//@Service
//public class ProductImageServiceImpl implements ProductImageService {
//
//    private final ProductImageRepository productImageRepository;
//    private final ProductRepository productRepository;
//    private final FileServiceImplementation fileService;
//    private final String uploadDir = "C:/Users/mohda/IdeaProjects/Myntra_Frontend/public/images/";
//    private final ProductImageMapper productImageMapper;
//
//    @Autowired
//    public ProductImageServiceImpl(ProductImageRepository productImageRepository, ProductRepository productRepository, FileServiceImplementation fileService, ProductImageMapper productImageMapper) {
//        this.productImageRepository = productImageRepository;
//        this.productRepository = productRepository;
//        this.fileService = fileService;
//        this.productImageMapper = productImageMapper;
//    }
//
//    @Override
//    public ProductImageDTO saveProductImage(MultipartFile file, Long productId) throws IOException {
//        String fileName = fileService.uploadFile(uploadDir, file);
//
//        Product product = productRepository.findById(productId)
//                .orElseThrow(() -> new RuntimeException("Product not found "));
//
//        ProductImageTable productImage = new ProductImageTable();
//        productImage.setProduct(product);
//        productImage.setImagePath(uploadDir + fileName);
//
//        product.setImageURL(fileName);
//        productRepository.save(product);
//
//        ProductImageTable save = productImageRepository.save(productImage);
//        return productImageMapper.apply(save);
//    }
//}


// File: ProductReviewServiceImplementation.java

//package com.backend.ecommerce.implementation;
//
//import com.backend.ecommerce.entity.ProductReview;
//import com.backend.ecommerce.exception.ProductReviewNotFoundException;
//import com.backend.ecommerce.repository.ProductReviewRepository;
//import com.backend.ecommerce.service.ProductReviewService;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.stereotype.Service;
//import org.springframework.transaction.annotation.Transactional;
//
//import java.util.List;
//
//@Transactional
//@Service
//public class ProductReviewServiceImplementation implements ProductReviewService {
//
//    private final ProductReviewRepository productReviewRepository;
//
//    @Autowired
//    public ProductReviewServiceImplementation(ProductReviewRepository productReviewRepository) {
//        this.productReviewRepository = productReviewRepository;
//    }
//
//    @Override
//    public ProductReview create(ProductReview productReview) {
//        return productReviewRepository.save(productReview);
//    }
//
//    @Override
//    public ProductReview update(int productReviewId, ProductReview productReview) {
//        ProductReview existingProductReview = productReviewRepository.findById(productReviewId)
//                .orElseThrow(() -> new ProductReviewNotFoundException("Product review not found with this id: " + productReviewId));
//        existingProductReview.setComment(productReview.getComment());
//        existingProductReview.setRating(productReview.getRating());
//        return productReviewRepository.save(existingProductReview);
//    }
//
//    @Override
//    public void delete(int productReviewId) {
//        productReviewRepository.deleteById(productReviewId);
//    }
//
//    @Override
//    public List<ProductReview> findByProductId(Long productId) {
//        return productReviewRepository.findByProductId(productId);
//    }
//
//    @Override
//    public List<ProductReview> findByUserId(Long userId) {
//        return productReviewRepository.findByUserId(userId);
//    }
//}


// File: ProductServiceImplementation.java

package com.backend.ecommerce.implementation;

import com.backend.ecommerce.mapper.ProductMapper;
import com.backend.ecommerce.records.ProductDTO;
import com.backend.ecommerce.records.ProductResponse;
import com.backend.ecommerce.entity.Category;
import com.backend.ecommerce.entity.Product;
import com.backend.ecommerce.exception.CategoryNotFoundException;
import com.backend.ecommerce.exception.ProductNotFoundException;
import com.backend.ecommerce.repository.CategoryRepository;
import com.backend.ecommerce.repository.ProductRepository;
import com.backend.ecommerce.service.ProductService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;

import java.awt.print.Pageable;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class ProductServiceImplementation implements ProductService {

    private final CategoryRepository categoryRepository;
    private final ProductRepository productRepository;
    private final ProductMapper productMapper;

    @Autowired
    public ProductServiceImplementation(CategoryRepository categoryRepository, ProductRepository productRepository, ProductMapper productMapper) {
        this.categoryRepository = categoryRepository;
        this.productRepository = productRepository;
        this.productMapper = productMapper;
    }

    @Override
    public ProductDTO createProduct(Product product) {
        Product savedProduct = productRepository.save(product);
        return productMapper.apply(savedProduct);
    }

    @Override
    public List<ProductDTO> addAll(List<Product> products) {         // Save all products at once
            List<Product> savedProducts = productRepository.saveAll(products);
            // Map the saved products to DTOs
        Collectors Collectors;
        return savedProducts.stream()
                .map(productMapper::apply)
                .toList();
    }

    @Override
    public List<ProductDTO> getAllProducts() {
        List<Product> productList = productRepository.findAll();
        return productList.stream().map(productMapper::apply).toList();
    }

    @Override
    public ProductDTO getProductById(Long id) {
        Product product = productRepository.findById(id).orElseThrow(() -> new ProductNotFoundException("Product not found with the id: " + id));
        return productMapper.apply(product);
    }

    @Override
    public ProductDTO updateProduct(Long id, Product product) {
        Product existingProduct = productRepository.findById(id).orElseThrow(() -> new ProductNotFoundException("Product not found " + id));
        existingProduct.setId(product.getId());
        existingProduct.setName(product.getName());
        existingProduct.setPrice(product.getPrice());
        Product savedProduct = productRepository.save(existingProduct);
        return productMapper.apply(savedProduct);
    }

    @Override
    public List<ProductDTO> getProductByCategory(Long catId) {
        Category category = categoryRepository.findById(catId).orElseThrow(() -> new CategoryNotFoundException("Category not found with this Id : " + catId));
        List<Product> categoryProducts = category.getProducts();

//        using loops

//        List<ProductDTO> categoryProductsDTO = new ArrayList<>();
//        for (int i = 0; i < categoryProducts.size(); i++) {
//            ProductDTO productDTO = productMapper.apply(categoryProducts.get(i));
//            categoryProductsDTO.add(productDTO);
//        }
//        return categoryProductsDTO;


//         Using lambda

//        categoryProducts.stream().map((categoryProduct) -> productMapper.apply(categoryProduct)).collect(Collectors.toList());


        // using method referencing

        return categoryProducts.stream().map(productMapper::apply).toList();
    }

    @Override
    public ProductDTO assignCategoryToProduct(Long productId, Long categoryId) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new ProductNotFoundException("Product not found"));

        Category category = categoryRepository.findById(categoryId)
                .orElseThrow(() -> new CategoryNotFoundException("Category not found"));


        Long id = category.getId();
//        product.getCategoryIds().add(id);// TODO fix this function
        Product savedProduct = productRepository.save(product);
        return productMapper.apply(savedProduct);
    }

    @Override
    public ProductDTO deleteProduct(Long id) {
        Optional<Product> product = productRepository.findById(id);
        productRepository.deleteById(id);
        if (product.isPresent()) {
            return productMapper.apply(product.get());
        }
        throw new ProductNotFoundException("Product not found");
    }

    @Override
    public ProductResponse getAllProductWithPagination(Integer pageNo, Integer pageSize) {
        Pageable pageable = (Pageable) PageRequest.of(pageNo, pageSize);
        Page<Product> productPage = productRepository.findAll((PageRequest) pageable);
        List<Product> productList = productPage.getContent();
        return new ProductResponse(productList, pageNo, pageSize, productPage.getTotalElements(), productPage.getTotalPages(), productPage.isLast());
    }

    @Override
    public ProductResponse getProductWithPaginationAndSorting(Integer pageNo, Integer pageSize, String sortBy, String sortOrder) {
        Sort sort = sortOrder.equalsIgnoreCase("asc") ? Sort.by(sortBy).ascending() : Sort.by(sortBy).descending();
        Pageable pageable = (Pageable) PageRequest.of(pageNo, pageSize, sort);
        Page<Product> productPage = productRepository.findAll((PageRequest) pageable);
        List<Product> productList = productPage.getContent();
        return new ProductResponse(productList, pageNo, pageSize, productPage.getTotalElements(), productPage.getTotalPages(), productPage.isLast());
    }

    @Override
    public ProductResponse searchProducts(String query, Integer pageNumber, Integer pageSize, String sortBy, String sortOrder) {
        // Create pageable object with sorting
        Sort sort = Sort.by(Sort.Order.by(sortBy));
        if (sortOrder.equalsIgnoreCase("desc")) {
            sort = sort.descending();
        }
        PageRequest pageRequest = PageRequest.of(pageNumber, pageSize, sort);

        // Perform search with pagination and sorting
        Page<Product> products = productRepository.search(query, pageRequest);
        return new ProductResponse(
                products.getContent(), // List<Product>
                products.getNumber(),  // Page number
                products.getSize(),    // Page size
                products.getTotalElements(), // Total number of products
                products.getTotalPages(), // Total number of pages
                products.isLast() // Is last page
        );
    }

    @Override
    public List<Product> searchProducts(String query) {
        return productRepository.findByNameContainingIgnoreCase(query);
    }
}


// File: S3ImageUploader.java

package com.backend.ecommerce.implementation;

import com.backend.ecommerce.entity.Product;
import com.backend.ecommerce.exception.ImageUploadException;
import com.backend.ecommerce.mapper.ProductMapper;
import com.backend.ecommerce.records.ProductDTO;
import com.backend.ecommerce.service.ImageUploader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import software.amazon.awssdk.core.sync.RequestBody;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.*;
import software.amazon.awssdk.services.s3.presigner.S3Presigner;
import software.amazon.awssdk.services.s3.presigner.model.GetObjectPresignRequest;
import software.amazon.awssdk.services.s3.presigner.model.PresignedGetObjectRequest;

import java.io.IOException;
import java.time.Duration;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class S3ImageUploader implements ImageUploader {

    private final S3Client s3Client;
    private final String bucketName;
    private final ProductServiceImplementation productService;
    private final ProductMapper productMapper;
    private final S3Presigner s3Presigner;

    @Autowired
    public S3ImageUploader(S3Client s3Client,
                           @Value("${app.s3.bucket}") String bucketName,
                           ProductServiceImplementation productService,
                           ProductMapper productMapper,
                           S3Presigner s3Presigner) {
        this.s3Client = s3Client;
        this.bucketName = bucketName;
        this.productService = productService;
        this.productMapper = productMapper;
        this.s3Presigner = s3Presigner;
    }

    @Override
    public String uploadImage(MultipartFile image, Long productId) {
        Product product;

        String actualFilename = image.getOriginalFilename();
        String fileName = UUID.randomUUID().toString() + actualFilename.substring(actualFilename.lastIndexOf("."));

        try {
            product = productMapper.reverse(productService.getProductById(productId));
            s3Client.putObject(PutObjectRequest.builder()
                            .bucket(bucketName)
                            .key(fileName)
                            .build(),
                    RequestBody.fromInputStream(image.getInputStream(), image.getSize()));
            product.setImageURL(fileName);
            productService.createProduct(product);
            return fileName;
        } catch (IOException e) {
            throw new ImageUploadException("Error while uploading image " + e.getMessage());
        }
    }

    @Override
    public List<String> allImages() {
        ListObjectsV2Request listRequest = ListObjectsV2Request.builder()
                .bucket(bucketName)
                .build();

        ListObjectsV2Response listResponse = s3Client.listObjectsV2(listRequest);

        return listResponse.contents().stream()
                .map(S3Object::key)
                .map(this::preSignedUrl)
                .collect(Collectors.toList());
    }

    @Override
    public String preSignedUrl(String fileName) {
        GetObjectPresignRequest presignRequest = GetObjectPresignRequest.builder()
                .signatureDuration(Duration.ofHours(1))
                .getObjectRequest(GetObjectRequest.builder()
                        .bucket(bucketName)
                        .key(fileName)
                        .build())
                .build();

        PresignedGetObjectRequest presignedRequest = s3Presigner.presignGetObject(presignRequest);
        return presignedRequest.url().toString();
    }

    @Override
    public String getImageUrlByName(String fileName) {
        return preSignedUrl(fileName);
    }
}


// File: SizeServiceImplementation.java

package com.backend.ecommerce.implementation;

import com.backend.ecommerce.entity.Size;
import com.backend.ecommerce.repository.SizeRepository;
import com.backend.ecommerce.service.SizeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class SizeServiceImplementation implements SizeService {
    @Autowired
    private SizeRepository sizeRepository;

    public Size createSize(Size size) {
        return sizeRepository.save(size);
    }

    public List<Size> getAllSizes() {
        return sizeRepository.findAll();
    }
}


// File: TransactionServiceImplementation.java

package com.backend.ecommerce.implementation;

import com.backend.ecommerce.entity.Transaction;
import com.backend.ecommerce.repository.TransactionRepository;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
@AllArgsConstructor
public class TransactionServiceImplementation implements com.backend.ecommerce.service.TransactionService {

    TransactionRepository transactionRepository;

    @Override
    public List<Transaction> getAllTransactions() {
        return transactionRepository.findAll();
    }

    @Override
    public Transaction getTransactionById(Long id) {
        return transactionRepository.findById(id).orElseThrow(() -> new RuntimeException("Transaction not found"));
    }

    @Override
    public Transaction saveTransaction(Transaction transaction) {
        return transactionRepository.save(transaction);
    }

    @Override
    public void deleteTransaction(Long id) {
        transactionRepository.deleteById(id);
    }

    @Override
    public Transaction updateTransaction(Transaction transaction, Long id) {
        Optional<Transaction> byId = transactionRepository.findById(id);
        if (byId.isPresent()) {
            Transaction updatedTransaction = transactionRepository.save(transaction);
            updatedTransaction.setTransactionAmount(transaction.getTransactionAmount());
            updatedTransaction.setTransactionType(transaction.getTransactionType());
            updatedTransaction.setTransactionStatus(transaction.getTransactionStatus());
            return transactionRepository.save(updatedTransaction);
        } else {
            throw new RuntimeException("Transaction not found");
        }
    }



}


// File: UserBankDetailsServiceImplementation.java

//package com.backend.ecommerce.implementation;
//
//import com.backend.ecommerce.entity.User;
//import com.backend.ecommerce.entity.UserBankDetails;
//import com.backend.ecommerce.exception.ResourceNotFoundException;
//import com.backend.ecommerce.repository.UserBankDetailsRepository;
//import com.backend.ecommerce.repository.UserRepository;
//import com.backend.ecommerce.service.UserBankDetailsService;
//import lombok.AllArgsConstructor;
//import org.springframework.stereotype.Service;
//
//import java.util.List;
//import java.util.Optional;
//
//@Service
//@AllArgsConstructor
//public class UserBankDetailsServiceImplementation implements UserBankDetailsService {
//
//    private final UserBankDetailsRepository repository;
//    private final UserRepository userRepository;
//
//    public List<UserBankDetails> getAllBankDetails() {
//        return repository.findAll();
//    }
//
//    public Optional<UserBankDetails> getBankDetailsById(Long id) {
//        return repository.findById(id);
//    }
//
//    public List<UserBankDetails> getBankDetailsByUserId(Long userId) {
//        return repository.findByUserId(userId);
//    }
//
//    public List<UserBankDetails> getPrimaryBankDetails(Boolean isPrimary) {
//        return repository.findByIsPrimary(isPrimary);
//    }
//
//    public List<UserBankDetails> getBankDetailsByStatus(String status) {
//        return repository.findByStatus(status);
//    }
//
//    public UserBankDetails saveBankDetails(Long userId, UserBankDetails bankDetails) {
//        User user = userRepository.findById(userId).orElseThrow(() -> new ResourceNotFoundException("User not found with this id: " + userId));
//        user.setUserBankDetails(bankDetails);
//        bankDetails.setUser(user);
//        return repository.save(bankDetails);
//    }
//
//    public void deleteBankDetails(Long id) {
//        repository.deleteById(id);
//    }
//}


// File: UserServiceImplementation.java


package com.backend.ecommerce.implementation;

import com.backend.ecommerce.authentication.AuthenticationResponse;
import com.backend.ecommerce.enums.Role;
import com.backend.ecommerce.mapper.UserMapper;
import com.backend.ecommerce.dto.EmailDetails;
import com.backend.ecommerce.records.UserDTO;
import com.backend.ecommerce.exception.DuplicateEntryException;
import com.backend.ecommerce.entity.User;
import com.backend.ecommerce.exception.UserNotFoundException;
import com.backend.ecommerce.repository.EmailService;
import com.backend.ecommerce.repository.UserRepository;
import com.backend.ecommerce.security.JWTService;
import com.backend.ecommerce.service.UserService;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Objects;

@Service
public class UserServiceImplementation implements UserService {

    private final UserRepository userRepository;
    private final UserMapper customModelMapper;
    private final EmailService emailService;
    private final JWTService jwtService;
    private final AuthenticationManager authenticationManager;

    private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    @Autowired
    public UserServiceImplementation(UserRepository userRepository, UserMapper customModelMapper, EmailService emailService, JWTService jwtService, @Qualifier("authenticationManager") AuthenticationManager authenticationManager) {
        this.userRepository = userRepository;
        this.customModelMapper = customModelMapper;
        this.emailService = emailService;
        this.jwtService = jwtService;
        this.authenticationManager = authenticationManager;
    }

//    public AuthenticationResponse createUser (RegisterRequest request) {
//        var user = User.builder()
//                .firstName(request.getFirstName())
//                .lastName(request.getLastName())
//                .email(request.getEmail())
//                .password(passwordEncoder.encode(request.getPassword()))
//                .role(Role.ADMIN)
//                .build();
//        User savedUser = userRepository.save(user);
//        UserDTO userDTO = customModelMapper.apply(savedUser);
//        return new AuthenticationResponse(jwtService.generateToken(savedUser), userDTO);
//    }

//    @Override
//    public UserDTO createUser(UserDTO userDTO) {
//        if (!userRepository.existsByEmail(userDTO.email())) {
//            User user = customModelMapper.reverse(userDTO);
//            User savedUser = userRepository.save(user);
//            EmailDetails emailDetails = EmailDetails.builder()
//                    .recipient(savedUser.getEmail())
//                    .subject("Account Creation")
//                    .messageBody("Congratulations! You have successfully created your account!")
//                    .build();
//            emailService.sendEmailAlert(emailDetails);
//            return customModelMapper.apply(userRepository.save(savedUser));
//        }
//        throw new DuplicateEntryException("Email already exists");
//    }

    @Override
    public UserDTO getUserById(Long id) {
        User user = userRepository.findById(id).orElseThrow(() -> new UserNotFoundException("User with this id " + id + " not found"));
        return customModelMapper.apply(user);
    }

    @Override
    public List<UserDTO> getAllUsers() {
        return userRepository.findAll().stream().map(customModelMapper::apply).toList();
    }

//    @Override
//    public UserDTO updateUser(Long userId, UserDTO userDTO) {
//        // Check for duplicate email entries
//        if (isDuplicate(userDTO)) {
//            throw new DuplicateEntryException(userDTO.email());
//        }
//
//        // Fetch existing user from the repository
//        User existingUser = userRepository.findById(userId)
//                .orElseThrow(() -> new UserNotFoundException("User not found with this id: " + userId));
//
//        // Map updated values from UserDTO to User entity
//        User updatedValues = customModelMapper.reverse(userDTO);
//
//        // Copy properties from updatedValues to existingUser, excluding id and password
//        BeanUtils.copyProperties(updatedValues, existingUser, "id", "password"); // This line copies properties from updatedValues (which contains the immutable list) to existingUser.
//
//        // Save the updated user and return the UserDTO representation
//        return customModelMapper.apply(userRepository.save(existingUser));
//
//    }


//    @Override
//    public UserDTO updateUser(Long userId, UserDTO userDTO) {
//        // Check for duplicate email entries
//        if (isDuplicate(userDTO)) {
//            throw new DuplicateEntryException(userDTO.email());
//        }
//
//        // Fetch existing user from the repository
//        User existingUser = userRepository.findById(userId)
//                .orElseThrow(() -> new UserNotFoundException("User not found with this id: " + userId));
//
//        // Map updated values from UserDTO to User entity
//        User updatedValues = customModelMapper.reverse(userDTO);
//
//        // Copy properties from updatedValues to existingUser, excluding id, password, and addressList
//        BeanUtils.copyProperties(updatedValues, existingUser, "id", "password", "addressList");
//
//        // Update the address list manually
//        existingUser.getAddressList().clear();
//        existingUser.getAddressList().addAll(updatedValues.getAddressList());
//
//        // Save the updated user and return the UserDTO representation
//        return customModelMapper.apply(userRepository.save(existingUser));
//    }


    @Override
    public UserDTO updateUser(Long userId, UserDTO userDTO) {
//        // Check for duplicate email entries
//        if (isDuplicate(userDTO)) {
//            throw new DuplicateEntryException(userDTO.email());
//        }

        // Fetch existing user from the repository
        User existingUser = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with this id: " + userId));

        // Map updated values from UserDTO to User entity
        User updatedValues = customModelMapper.reverse(userDTO);

        // Copy properties from updatedValues to existingUser, excluding id, password, addressList, and createdat
        BeanUtils.copyProperties(updatedValues, existingUser, "id", "password", "addressList", "createdat");

        // Update the address list manually
        existingUser.getAddressList().clear();
        existingUser.getAddressList().addAll(updatedValues.getAddressList());

        // Save the updated user and return the UserDTO representation
        return customModelMapper.apply(userRepository.save(existingUser));
    }


    public boolean verifyUser(Long userId, String firstName, String lastName, Long phoneNumber) {
        isCustomerExists(userId);
        return userRepository.existsByIdAndFirstNameAndLastNameAndDefaultPhoneNumber(userId, firstName, lastName, phoneNumber);
    }

    @Override
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }


    @Override
    public UserDTO getUserByEmail(String email) {
        return customModelMapper.apply(userRepository.findByEmail(email).orElseThrow(() -> new UserNotFoundException("User with the " + email + " not found")));
    }


    public ResponseEntity<?> register(User user) {

        if (!userRepository.existsByEmail(user.getEmail())) {
            user.setPassword(passwordEncoder.encode(user.getPassword()));

            user.setRole(Role.ADMIN);
            User savedUser = userRepository.save(user);
            System.out.println("User saved to the database");

            EmailDetails emailDetails = EmailDetails.builder()
                    .recipient(savedUser.getEmail())
                    .subject("Account Creation")
                    .messageBody("Congratulations! You have successfully created your account!")
                    .build();
            emailService.sendEmailAlert(emailDetails);

            System.out.println("Password : " + user.getPassword());

            String token = jwtService.generateToken(savedUser.getEmail(), savedUser.getRole().name());
            System.out.println(token);
            System.out.println(jwtService.getRoleFromToken(token));
            return ResponseEntity.ok(new AuthenticationResponse(token, customModelMapper.apply(savedUser)));
        } else {

            throw new DuplicateEntryException("Email already exists");
        }
    }


    public String login(String email, String password) {
        User user = userRepository.findByEmail(email).orElseThrow(() -> new UserNotFoundException("User not found with this email : " + email));

        Authentication authentication = authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(email, password));

        if (authentication.isAuthenticated()) {

            //Extract role from user entity
            String role = user.getRole().name();

            return jwtService.generateToken(email, role);
        }
        return "fail";
    }

    private boolean isCustomerExists(Long id) {
        return userRepository.existsById(id);
    }

    private boolean isDuplicate(UserDTO userDTO) {
        if (userDTO == null) {
            throw new RuntimeException("UserDTO is null");
        }
        if (Objects.nonNull(userDTO.defaultPhoneNumber()) && userRepository.existsByDefaultPhoneNumber(userDTO.defaultPhoneNumber())) {
            return true;
        }
        return Objects.nonNull(userDTO.email()) && userRepository.existsByEmail(userDTO.email());
    }

}


// File: AddressMapper.java

package com.backend.ecommerce.mapper;

import com.backend.ecommerce.entity.Address;
import com.backend.ecommerce.entity.User;
import com.backend.ecommerce.records.AddressDTO;
import com.backend.ecommerce.records.UserDTO;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class AddressMapper implements EntityDTOMapper<Address, AddressDTO> {
    @Override
    public AddressDTO apply(Address entity) {
        // Create an AddressMapper instance to convert Address entities to AddressDTOs
        AddressMapper addressMapper = new AddressMapper();

        // Convert List<Address> to List<AddressDTO>
        List<AddressDTO> addressDTOList = entity.getUser().getAddressList()
                .stream()
                .map(addressMapper::apply) // Map each Address to AddressDTO
                .toList();

        return new AddressDTO(
                entity.getId(),
                entity.getAddressType(),
                entity.getStreetAddress(),
                entity.getPinCode(),
                entity.getPhoneType(),
                new UserDTO(
                        entity.getUser().getId(),
                        entity.getUser().getFirstName(),
                        entity.getUser().getLastName(),
                        entity.getUser().getEmail(),
                        entity.getUser().getRole(),
                        entity.getUser().getDefaultPhoneNumber(),
                        addressDTOList // Pass the mapped List<AddressDTO>
                ),
                entity.getCity() // Assuming you're using City directly
        );
    }

    @Override
    public Address reverse(AddressDTO dto) {
        Address address = new Address();
        address.setId(dto.id());
        address.setAddressType(dto.addressType());
        address.setStreetAddress(dto.streetAddress());
        address.setPinCode(dto.pinCode());
        address.setPhoneType(dto.phoneType());

        // Don't set the User here, it will be handled in the UserMapper

        if (dto.city() != null) {
            address.setCity(dto.city());
        }

        return address;
    }
}


// File: CartMapper.java

package com.backend.ecommerce.mapper;

import com.backend.ecommerce.entity.Cart;
import com.backend.ecommerce.entity.CartProducts;
import com.backend.ecommerce.records.CartDTO;
import com.backend.ecommerce.records.CartProductDTO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class CartMapper implements EntityDTOMapper<Cart, CartDTO> {
    private final CartProductsMapper cartProductsMapper;
    @Autowired
    public CartMapper(CartProductsMapper cartProductsMapper) {
        this.cartProductsMapper = cartProductsMapper;
    }

    @Override
    public CartDTO apply(Cart cart) {
        List<CartProductDTO> cartProductDTOS = cart.getCartProducts().stream().map((cartProductsMapper::apply)).toList();
        return new CartDTO(
                cart.getId(),
                cart.getUser().getId(),
                cartProductDTOS
        );
    }

    @Override
    public Cart reverse(CartDTO dto) {
        return null;
    }
}


// File: CartProductsMapper.java

package com.backend.ecommerce.mapper;

import com.backend.ecommerce.entity.CartProducts;
import com.backend.ecommerce.records.CartProductDTO;
import org.springframework.stereotype.Service;

@Service
public class CartProductsMapper implements EntityDTOMapper<CartProducts, CartProductDTO> {
    @Override
    public CartProductDTO apply(CartProducts cartProducts) {
        return new CartProductDTO(
                cartProducts.getId(),
                cartProducts.getProduct(),
                cartProducts.getQuantity(),
                cartProducts.getAvailabilityStatus().toString()
        );
    }

    @Override
    public CartProducts reverse(CartProductDTO dto) {
        CartProducts cartProducts = new CartProducts();
        cartProducts.setProduct(dto.product());
        cartProducts.setQuantity(dto.quantity());
        cartProducts.setId(dto.id());
        return cartProducts;
    }
}


// File: CategoryMapper.java

package com.backend.ecommerce.mapper;

import com.backend.ecommerce.entity.Category;
import com.backend.ecommerce.entity.Product;
import com.backend.ecommerce.exception.ProductNotFoundException;
import com.backend.ecommerce.records.CategoryDTO;
import com.backend.ecommerce.repository.ProductRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class CategoryMapper implements EntityDTOMapper<Category, CategoryDTO> {

    private final ProductRepository productRepository;

    @Autowired
    public CategoryMapper(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    @Override
    public CategoryDTO apply(Category category) {

        List<Long> productIds = category.getProducts().stream().map(Product::getId).toList();

        return new CategoryDTO(category.getId(), category.getName(), category.getDescription(), productIds);
    }

    @Override
    public Category reverse(CategoryDTO dto) {

        List<Product> productList = dto.productIds().stream().map(productId -> productRepository.findById(productId).orElseThrow(() -> new ProductNotFoundException("Product not found with this id:  " + productId))).toList();

        Category category = new Category();
        category.setId(dto.id());
        category.setName(dto.name());
        category.setDescription(dto.description());
        category.setProducts(productList);
        return category;
    }
}


// File: EntityDTOMapper.java

package com.backend.ecommerce.mapper;

public interface EntityDTOMapper<E, D> {
    D apply(E entity);
    E reverse(D dto);
}


// File: InventoryMapper.java

package com.backend.ecommerce.mapper;

import com.backend.ecommerce.entity.Inventory;
import com.backend.ecommerce.records.InventoryDTO;
import org.springframework.stereotype.Component;

@Component
public class InventoryMapper implements EntityDTOMapper<Inventory, InventoryDTO> {
    @Override
    public InventoryDTO apply(Inventory entity) {
        return new InventoryDTO(entity.getId(), entity.getProduct(), entity.getQuantity());
    }

    @Override
    public Inventory reverse(InventoryDTO dto) {
        Inventory entity = new Inventory();
        entity.setId(dto.id());
        entity.setProduct(dto.product());
        entity.setQuantity(dto.quantity());
        return entity;
    }
}


// File: ProductImageMapper.java

package com.backend.ecommerce.mapper;

import com.backend.ecommerce.entity.ProductImageTable;
import com.backend.ecommerce.records.ProductImageDTO;
import org.springframework.stereotype.Component;

@Component
public class ProductImageMapper implements EntityDTOMapper<ProductImageTable, ProductImageDTO> {
    @Override
    public ProductImageDTO apply(ProductImageTable entity) {
        return new ProductImageDTO(entity.getId(), entity.getProduct(), entity.getImagePath());
    }

    @Override
    public ProductImageTable reverse(ProductImageDTO dto) {
        ProductImageTable entity = new ProductImageTable();
        entity.setId(dto.id());
        entity.setProduct(dto.product());
        entity.setImagePath(dto.imagePath());
        return entity;
    }
}


// File: ProductMapper.java

package com.backend.ecommerce.mapper;

import com.backend.ecommerce.entity.Color;
import com.backend.ecommerce.entity.Size;
import com.backend.ecommerce.records.ProductDTO;
import com.backend.ecommerce.entity.Product;
import com.backend.ecommerce.entity.Category;
import com.backend.ecommerce.repository.CategoryRepository;
import com.backend.ecommerce.repository.ColorRepository;
import com.backend.ecommerce.repository.SizeRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

@Component
public class ProductMapper implements EntityDTOMapper<Product, ProductDTO> {

    private final CategoryRepository categoryRepository;
    private final SizeRepository sizeRepository;
    private final ColorRepository colorRepository;

    @Autowired
    public ProductMapper(CategoryRepository categoryRepository, SizeRepository sizeRepository, ColorRepository colorRepository) {
        this.categoryRepository = categoryRepository;
        this.sizeRepository = sizeRepository;
        this.colorRepository = colorRepository;
    }

    @Override
    public ProductDTO apply(Product product) {
        List<Long> categoryIds = product.getCategories().stream()
                .map(Category::getId)
                .collect(Collectors.toList());

        List<String> sizes = product.getSizes().stream()
                .map(Size::getName)
                .toList();

        List<String> colors = product.getColors().stream()
                .map(Color::getName)
                .toList();

        return new ProductDTO(
                product.getId(),
                product.getName(),
                product.getImageURL(),
                product.getPrice(),
                product.getDescription(),
                product.getBrand(),
                product.getReturnPeriod(),
                product.getStockQuantity(),
                product.getAverageRating(),
                product.getDiscountedPercentage(),
                product.getCurrentPrice(),
                product.getDeliveryDate(),
                product.getDateAdded(),
                product.getDateUpdated(),
                product.getRating(),
                product.getAvailability(),
                sizes,
                colors,
                categoryIds,
                product.getProductImages()
        );
    }

    @Override
    public Product reverse(ProductDTO dto) {
        // Fetch the category entities based on the categoryIds in the DTO
        List<Category> categories = dto.categoryIds().stream()
                .map(categoryId -> categoryRepository.findById(categoryId)
                        .orElseThrow(() -> new RuntimeException("Category not found: " + categoryId)))
                .collect(Collectors.toList());

        // Convert size names to Size entities
        List<Size> sizes = dto.sizes().stream()
                .map(sizeName -> sizeRepository.findByName(sizeName)
                        .orElseThrow(() -> new RuntimeException("Size not found: " + sizeName)))
                .toList();

        // Convert color names to Color entities
        List<Color> colors = dto.colors().stream()
                .map(colorName -> colorRepository.findByName(colorName)
                        .orElseThrow(() -> new RuntimeException("Color not found: " + colorName)))
                .toList();

        // Create a new Product entity and set the fields from the DTO
        Product product = new Product();
        product.setId(dto.id());
        product.setName(dto.name());
        product.setImageURL(dto.imageURL());
        product.setPrice(dto.price());
        product.setDescription(dto.description());
        product.setBrand(dto.brand());
        product.setReturnPeriod(dto.returnPeriod());
        product.setStockQuantity(dto.stockQuantity());
        product.setAverageRating(dto.averageRating());
        product.setDiscountedPercentage(dto.discountedPercentage());
        product.setCurrentPrice(dto.currentPrice());
        product.setDeliveryDate(dto.deliveryDate());
        product.setDateAdded(dto.dateAdded());
        product.setDateUpdated(dto.dateUpdated());
        product.setRating(dto.rating());
        product.setAvailability(dto.availability());
        product.setCategories(categories); // Set the fetched categories
        product.setSizes(sizes);
        product.setColors(colors);
        product.setProductImages(dto.productImages());

        return product;
    }
}


// File: RatingMapper.java

package com.backend.ecommerce.mapper;

import com.backend.ecommerce.entity.Rating;
import com.backend.ecommerce.records.RatingDTO;

public class RatingMapper implements EntityDTOMapper<Rating, RatingDTO> {
    @Override
    public RatingDTO apply(Rating rating) {



        return new RatingDTO(rating.getId(), rating.getStars(), rating.getCount(), rating.getComment(), rating.getProduct(), rating.getUser());
    }

    @Override
    public Rating reverse(RatingDTO dto) {
        Rating rating = new Rating();
        rating.setId(dto.id());
        rating.setUser(dto.user());
        rating.setProduct(dto.product());
        rating.setCount(dto.count());
        rating.setStars(dto.start());
        rating.setComment(dto.comment());
        return rating;
    }
}


// File: UserMapper.java

package com.backend.ecommerce.mapper;

import com.backend.ecommerce.entity.Address;
import com.backend.ecommerce.entity.User;
import com.backend.ecommerce.records.AddressDTO;
import com.backend.ecommerce.records.UserDTO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

@Service
public class UserMapper implements EntityDTOMapper<User, UserDTO> {

    private final AddressMapper addressMapper;

    @Autowired
    public UserMapper(AddressMapper addressMapper) {
        this.addressMapper = addressMapper;
    }

    @Override
    public UserDTO apply(User user) {
        List<AddressDTO> addressDTOS = new ArrayList<>();
        if (user.getAddressList() != null) {
            addressDTOS = user.getAddressList().stream().map(addressMapper::apply).toList();
        }

        return new UserDTO(user.getId(), user.getFirstName(), user.getLastName(), user.getEmail(), user.getRole(), user.getDefaultPhoneNumber(), addressDTOS);

    }

//    public User reverse(UserDTO userDTO) {
//
//        List<Address> addressList = userDTO.addressList().stream().map(addressMapper::reverse).toList();  // this toList() method create immutable list which we can edit or modify
//
//        return new User(userDTO.firstName(), userDTO.lastName(), userDTO.email(), userDTO.defaultPhoneNumber(), addressList);
//    }

//    public User reverse(UserDTO userDTO) {
//        List<Address> addressList = new ArrayList<>(userDTO.addressList().stream().map(addressMapper::reverse).toList());
//        return new User(userDTO.firstName(), userDTO.lastName(), userDTO.email(), userDTO.defaultPhoneNumber(), addressList);
//    }

    public User reverse(UserDTO userDTO) {
        List<Address> addressList = new ArrayList<>(userDTO.addressList().stream().map(addressMapper::reverse).toList());
        User user = new User(userDTO.firstName(), userDTO.lastName(), userDTO.email(), userDTO.defaultPhoneNumber(), addressList);
        // Do not set createdat here
        return user;
    }
}


// File: AddressDTO.java

package com.backend.ecommerce.records;

import com.backend.ecommerce.entity.City;
import com.backend.ecommerce.enums.PhoneType;

public record AddressDTO(Long id,
                         String addressType,
                         String streetAddress,
                         String pinCode,
                         PhoneType phoneType,
                         UserDTO user,
                         City city
) {
}


// File: CartDTO.java

package com.backend.ecommerce.records;

import java.util.List;


public record CartDTO (Long id,
        Long userId,
        List<CartProductDTO> cartProducts) {
}


// File: CartItemsDTO.java

package com.backend.ecommerce.records;

import com.backend.ecommerce.entity.CartProducts;
import com.backend.ecommerce.entity.Product;

import java.math.BigDecimal;
import java.time.LocalDateTime;

public record CartItemsDTO(
        Long cartItemId,
        Product product,
        String productName,
        Integer quantity,
        BigDecimal unitPrice,
        BigDecimal totalPrice,
        String imageUri,
        Boolean availability,
        LocalDateTime addedOn,
        String productApiEndpoint
) {
    public CartItemsDTO(CartProducts ci) {
        this(
            ci.getId(),
            ci.getProduct(),
            ci.getProduct().getName(),
            ci.getQuantity(),
            ci.getProduct().getPrice(),
            ci.getProduct().getPrice().multiply(BigDecimal.valueOf(ci.getQuantity())),
            null, // imageUri
            null, // availability
            null, // addedOn
            null  // productApiEndpoint
        );
    }
}


// File: CartProductDTO.java

package com.backend.ecommerce.records;

import com.backend.ecommerce.entity.Product;


public record CartProductDTO ( Long id,
         Product product,
         Integer quantity,
         String availabilityStatus) {
}


// File: CategoryDTO.java

package com.backend.ecommerce.records;

import java.util.List;

public record CategoryDTO(
        Long id,
        String name,
        String description,
        List<Long> productIds
) {}


// File: ChangePassword.java

package com.backend.ecommerce.records;

public record ChangePassword(String password, String repeatPassword) {
}


// File: ErrorMessage.java

package com.backend.ecommerce.records;

import com.fasterxml.jackson.annotation.JsonInclude;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@JsonInclude(JsonInclude.Include.NON_NULL)
public record ErrorMessage(HttpStatus status, int statusCode, LocalDateTime timestamp, String message, String description) {}


// File: InventoryDTO.java

package com.backend.ecommerce.records;

import com.backend.ecommerce.entity.Product;

public record InventoryDTO(Long id, Product product, Integer quantity) {
}


// File: MailBody.java

package com.backend.ecommerce.records;

public record MailBody(String recipient,String messageBody, String subject, String attachment) {
}


// File: ProductDTO.java

package com.backend.ecommerce.records;

import com.backend.ecommerce.entity.ProductImageTable;
import com.backend.ecommerce.entity.Rating;
import com.backend.ecommerce.enums.AvailabilityStatus;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

public record ProductDTO(
        Long id,
        String name,
        String imageURL,
        BigDecimal price,
        String description,
        String brand,
        String returnPeriod,
        Integer stockQuantity,
        BigDecimal averageRating,
        BigDecimal discountedPercentage,
        BigDecimal currentPrice,
        LocalDate deliveryDate,
        LocalDateTime dateAdded,
        LocalDateTime dateUpdated,
        List<Rating> rating,
        AvailabilityStatus availability,
        List<String> sizes,
        List<String> colors,
        List<Long> categoryIds,
        List<ProductImageTable> productImages
) {}


// File: ProductImageDTO.java

package com.backend.ecommerce.records;

import com.backend.ecommerce.entity.Product;

public record ProductImageDTO(Long id, Product product, String imagePath) {
}


// File: ProductResponse.java

package com.backend.ecommerce.records;

import com.backend.ecommerce.entity.Product;

import java.util.List;

public record ProductResponse (List<Product> products,
                               Integer pageNumber,
                               Integer pageSize,
                               long totalElements,
                               int totalPages,
                               boolean isLast) {
}


// File: RatingDTO.java

package com.backend.ecommerce.records;

import com.backend.ecommerce.entity.Product;
import com.backend.ecommerce.entity.User;

public record RatingDTO(int id, float start, float count, String comment, Product product, User user) {
}


// File: UserDTO.java

package com.backend.ecommerce.records;

import com.backend.ecommerce.entity.Address;
import com.backend.ecommerce.enums.Role;

import java.util.List;

public record UserDTO(Long id,
                      String firstName,
                      String lastName,
                      String email,
                      Role role,
                      Long defaultPhoneNumber,
                      List<AddressDTO> addressList
) {
}


// File: AddressRepository.java

package com.backend.ecommerce.repository;

import com.backend.ecommerce.entity.Address;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface AddressRepository extends JpaRepository<Address, Long> {
    public Optional<Address> findByUserId(Long user_id);
}


// File: CartProductsRepository.java

package com.backend.ecommerce.repository;

import com.backend.ecommerce.entity.CartProducts;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

public interface CartProductsRepository extends JpaRepository<CartProducts, Long> {

    Optional<CartProducts> findByCartIdAndProductId(@Param("cart") Long cartId, @Param("product") Long productId);

    List<CartProducts> findAllByCartId(Long cartId);

    @Transactional
    void deleteAllByCartId(Long cart_id);
}


// File: CartRepository.java

package com.backend.ecommerce.repository;

import com.backend.ecommerce.entity.Cart;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface CartRepository extends JpaRepository<Cart, Long> {

    Optional<Cart> findByUserId(Long userId);
    void deleteByUserId(Long userId);

}


// File: CategoryRepository.java

package com.backend.ecommerce.repository;

import com.backend.ecommerce.entity.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {
}


// File: ColorRepository.java

package com.backend.ecommerce.repository;

import com.backend.ecommerce.entity.Color;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface ColorRepository extends JpaRepository<Color, Long> {
    Optional<Color> findByName(String colorName);
}


// File: EmailService.java

package com.backend.ecommerce.repository;

import com.backend.ecommerce.dto.EmailDetails;

public interface EmailService {

    void sendEmailAlert(EmailDetails emailDetails);
}


// File: ForgotPasswordRepository.java

package com.backend.ecommerce.repository;

import com.backend.ecommerce.entity.ForgotPassword;
import com.backend.ecommerce.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import java.util.Optional;

public interface ForgotPasswordRepository extends JpaRepository<ForgotPassword, Integer> {

    @Query("select fp from ForgotPassword fp where fp.otp = ?1 and fp.user = ?2")
    Optional<ForgotPassword> findByOtpAndUser(Integer otp, User user);
}


// File: InventoryRepository.java

package com.backend.ecommerce.repository;

import com.backend.ecommerce.entity.Inventory;
import com.backend.ecommerce.entity.Product;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface InventoryRepository extends JpaRepository<Inventory, Long> {
    Optional<Inventory> findByProduct(Product product);
}


// File: OrderProductsRepository.java

package com.backend.ecommerce.repository;

import com.backend.ecommerce.entity.OrderProducts;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderProductsRepository extends JpaRepository<OrderProducts, Long> {
}


// File: OrderRepository.java

package com.backend.ecommerce.repository;

import com.backend.ecommerce.entity.Order;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface OrderRepository extends JpaRepository<Order, Integer> {
}


// File: ProductImageRepository.java

package com.backend.ecommerce.repository;

import com.backend.ecommerce.entity.ProductImageTable;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ProductImageRepository extends JpaRepository<ProductImageTable, Long> {
}


// File: ProductRepository.java

package com.backend.ecommerce.repository;

import com.backend.ecommerce.entity.Product;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {

    @Query("SELECT p FROM Product p WHERE LOWER(p.name) LIKE LOWER(CONCAT('%', :query, '%'))")
    Page<Product> search(String query, Pageable pageable);

    List<Product> findByNameContainingIgnoreCase(String name);
}


// File: ProductReviewRepository.java

//package com.backend.ecommerce.repository;
//
//import com.backend.ecommerce.entity.ProductReview;
//import org.springframework.data.jpa.repository.JpaRepository;
//
//import java.util.List;
//
//public interface ProductReviewRepository extends JpaRepository<ProductReview, Integer> {
//
//    List<ProductReview> findByProductId(Long productId);
//
//    List<ProductReview> findByUserId(Long userId);
//}


// File: SizeRepository.java

package com.backend.ecommerce.repository;

import com.backend.ecommerce.entity.Size;
import org.springframework.data.jpa.repository.JpaRepository;

import javax.swing.text.html.Option;
import java.util.Optional;

public interface SizeRepository extends JpaRepository<Size, Long> {
    Optional<Size> findByName(String sizeName);
}


// File: TransactionRepository.java

package com.backend.ecommerce.repository;

import com.backend.ecommerce.entity.Transaction;
import org.springframework.data.jpa.repository.JpaRepository;

public interface TransactionRepository extends JpaRepository<Transaction, Long> {
}


// File: UserBankDetailsRepository.java

//package com.backend.ecommerce.repository;
//
//import com.backend.ecommerce.entity.User;
//import com.backend.ecommerce.entity.UserBankDetails;
//import org.springframework.data.jpa.repository.JpaRepository;
//import org.springframework.stereotype.Repository;
//
//import java.util.List;
//import java.util.Optional;
//
//@Repository
//public interface UserBankDetailsRepository extends JpaRepository<UserBankDetails, Long> {
//    List<UserBankDetails> findByUserId(Long userId);
//    List<UserBankDetails> findByIsPrimary(boolean isPrimary);
//    List<UserBankDetails> findByStatus(String status);
//    Optional<UserBankDetails> findByUserIdAndIsPrimaryTrue(Long userId);
//}


// File: UserRepository.java

package com.backend.ecommerce.repository;

import jakarta.transaction.Transactional;
import org.springframework.data.jpa.repository.JpaRepository;
import com.backend.ecommerce.entity.User;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);

    boolean existsByDefaultPhoneNumber(Long aLong);

    boolean existsByEmail(String email);

    boolean existsByIdAndFirstNameAndLastNameAndDefaultPhoneNumber(Long id, String firstName, String lastName, Long defaultPhoneNumber);


    @Transactional
    @Modifying
    @Query("update User u set u.password = ?2 where u.email = ?1")
    int updatePassword(String email, String password);

    User findByGoogleId(String googleId);
}


// File: JwtFilter.java

package com.backend.ecommerce.security;


import com.backend.ecommerce.utility.JwtBlacklistService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtFilter extends OncePerRequestFilter {
    @Autowired
    private JWTService jwtService;

    @Autowired
    MyUserDetailsService userDetailsService;

    @Autowired
    private JwtBlacklistService jwtBlacklistService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

//        String path = request.getRequestURI();
//        // Skip JWT filter for /signup and /login
//        if (path.contains("/api/users/signup") || path.contains("/api/users/login")) {
//            filterChain.doFilter(request, response);
//            return;
//        }

        String authHeader = request.getHeader("Authorization");
        String token = null;
        String email = null;
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            token = authHeader.substring(7);
            email = jwtService.extractUsername(token);
        }

        // check if the token is blacklisted
        if (jwtBlacklistService.isBlacklisted(token)) {
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, token);
            return;
        }

        if (email != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = userDetailsService.loadUserByUsername(email);
            if (jwtService.validateToken(token, userDetails)) {
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        filterChain.doFilter(request, response);
    }
}


// File: JWTService.java

package com.backend.ecommerce.security;

import com.backend.ecommerce.utility.JwtBlacklistService;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Service
public class JWTService {

    private String secretKey = "";
    @Autowired
    private JwtBlacklistService jwtBlacklistService;

    public JWTService() {
        try {
            KeyGenerator keyGenerator = KeyGenerator.getInstance("HmacSHA256");
            SecretKey key = keyGenerator.generateKey();
            secretKey = Base64.getEncoder().encodeToString(key.getEncoded());
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }

    public String generateToken(String email, String role) {

        Map<String, Object> claims = new HashMap<String, Object>();
        claims.put("roles", role);

        return Jwts.builder()
                .claims()
                .add(claims)
                .subject(email)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + 600 * 600 * 30))
                .and()
                .signWith(getKey())
                .compact();
    }

    public String getRoleFromToken(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(getKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
        return claims.get("roles", String.class); // extract the role from claims
    }

    private SecretKey getKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secretKey);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    private Claims extractAllClaimsFromToken(String token) {
        return Jwts.parser()
                .verifyWith(getKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    private <T> T extractClaim(String token, Function<Claims, T> claimResolver) {
        final Claims claims = extractAllClaimsFromToken(token);
        return claimResolver.apply(claims);
    }

    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }
    public void blacklistToken(String token) {
        jwtBlacklistService.isBlacklisted(token);
    }
}


// File: MyUserDetailsService.java

package com.backend.ecommerce.security;

import com.backend.ecommerce.entity.User;
import com.backend.ecommerce.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class MyUserDetailsService implements UserDetailsService {

    @Autowired
    private UserRepository repo;

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = repo.findByEmail(email).orElseThrow(() -> new UsernameNotFoundException("User not found with this email " + email));

        return new org.springframework.security.core.userdetails.User(
                user.getEmail(),
                user.getPassword(),
                user.getAuthorities()
        );
    }
}


// File: SecurityConfig.java

package com.backend.ecommerce.security;

import com.backend.ecommerce.authentication.OAuthAuthenticationSuccessHandler;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final UserDetailsService userDetailsService;
    private final JwtFilter jwtFilter;
    private final OAuthAuthenticationSuccessHandler oAuthAuthenticationSuccessHandler;

    @Autowired
    public SecurityConfig(UserDetailsService userDetailsService, JwtFilter jwtFilter, OAuthAuthenticationSuccessHandler oAuthAuthenticationSuccessHandler) {
        this.userDetailsService = userDetailsService;
        this.jwtFilter = jwtFilter;
        this.oAuthAuthenticationSuccessHandler = oAuthAuthenticationSuccessHandler;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(request -> request
                        .requestMatchers("/api/auth/**","api/products/**", "api/category/**", "api/inventory/**", "api/images/**", "api/s3/**", "api/sizes/**", "api/colors/**", "api/cart/**")
                        .permitAll()
                        .requestMatchers("/api/products").hasRole("ADMIN")
                        .requestMatchers("/api/products").hasRole("USER")
                        .anyRequest().authenticated())
                .oauth2Login(oauth2 ->
                                oauth2.successHandler(oAuthAuthenticationSuccessHandler))
                .httpBasic(Customizer.withDefaults())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }

    private CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:5173"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type", "X-Requested-With"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);

        return source;
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setPasswordEncoder(new BCryptPasswordEncoder(12));
        provider.setUserDetailsService(userDetailsService);
        return provider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) throws Exception {
        return configuration.getAuthenticationManager();
    }
}


// File: AddressService.java

package com.backend.ecommerce.service;

import com.backend.ecommerce.entity.Address;

import java.util.List;
import java.util.Optional;

public interface AddressService {
    static Address getAddress(Address address, Optional<Address> userAddressOptional) {
        Address existingAddress = userAddressOptional.get();

        // Update the address details
        existingAddress.setCity(address.getCity());
        existingAddress.setAddressType(address.getAddressType());
        existingAddress.setPhoneType(address.getPhoneType());
        existingAddress.setStreetAddress(address.getStreetAddress());
        existingAddress.setUser(address.getUser());
        existingAddress.setPinCode(address.getPinCode());
        return existingAddress;
    }

    Address save(Long userId, Address address);

    List<Address> getAll();

    Address updateAddressByUserId(Address address, Long userId);

    Address getAddressByUserId(Long id);

    String deleteAddressById(Long id);
}


// File: CartService.java

package com.backend.ecommerce.service;

import com.backend.ecommerce.records.CartDTO;
import com.backend.ecommerce.dto.CartItemsDTO;
import com.backend.ecommerce.records.CartProductDTO;
import com.backend.ecommerce.entity.Cart;
import com.backend.ecommerce.entity.CartProducts;

import java.util.List;
import java.util.stream.Collectors;

public interface CartService {
    CartProducts addProductToCart(Long userId, Long productId, Integer quantity);

    void removeProductFromCart(Long userId, Long productId, Integer quantity);

    List<Cart> getAllCarts();

    Cart getCart(Long cartId);

    List<CartItemsDTO> getCartItemsByUserId(Long userId);

    CartDTO getCartByUserId(Long userId);

    default CartDTO convertToDTO(Cart cart) {
        return new CartDTO(
                cart.getId(),
                cart.getUser().getId(),
                cart.getCartProducts().stream()
                        .map(this::convertCartProductToDTO)
                        .collect(Collectors.toList())
        );
    }

    default CartProductDTO convertCartProductToDTO(CartProducts cartProduct) {
        String availabilityStatus = (cartProduct.getAvailabilityStatus() != null) ?
                cartProduct.getAvailabilityStatus().name() :
                "UNAVAILABLE"; // Default to UNAVAILABLE if null
        return new CartProductDTO(
                cartProduct.getId(),
                cartProduct.getProduct(),
                cartProduct.getQuantity(),
                availabilityStatus
        );
    }
}


// File: CategoryService.java

package com.backend.ecommerce.service;

import com.backend.ecommerce.entity.Category;
import com.backend.ecommerce.records.CategoryDTO;

import java.util.List;

public interface CategoryService {
    List<CategoryDTO> findAll();

    CategoryDTO findById(Long id);

    List<CategoryDTO> getCategoryByProductId(Long productId);

    CategoryDTO create(Category category);

    String delete(Long id);

    CategoryDTO update(Category category, Long id);

    List<CategoryDTO> createListOfCategory(List<Category> categoryList);
}


// File: ColorService.java

package com.backend.ecommerce.service;

import com.backend.ecommerce.entity.Color;

import java.util.List;

public interface ColorService {
    Color createColor(Color color);
    List<Color> getAllColors();
}


// File: FileService.java

//package com.backend.ecommerce.service;
//
//import org.springframework.web.multipart.MultipartFile;
//
//import java.io.FileNotFoundException;
//import java.io.IOException;
//import java.io.InputStream;
//
//
//public interface FileService {
//
//    String uploadFile(String path, MultipartFile file) throws IOException;
//
//    InputStream getResourceFile(String path, String name) throws FileNotFoundException;
//}


// File: ForgotPasswordService.java

package com.backend.ecommerce.service;

import com.backend.ecommerce.records.ChangePassword;

public interface ForgotPasswordService {
    String verifyEmail(String email);
    String verifyOTP(Integer otp, String email);
    String changePasswordHandler(ChangePassword changePassword, String email);
}


// File: ImageUploader.java

package com.backend.ecommerce.service;

import org.springframework.web.multipart.MultipartFile;

import java.util.List;

public interface ImageUploader {
    String uploadImage(MultipartFile image, Long productId);

    List<String> allImages();

    String preSignedUrl(String fileName);

    String getImageUrlByName(String fileName);
}


// File: InventoryService.java

package com.backend.ecommerce.service;

import com.backend.ecommerce.entity.Inventory;
import com.backend.ecommerce.entity.Product;
import com.backend.ecommerce.exception.InsufficientStockException;
import com.backend.ecommerce.exception.InventoryNotFoundException;
import com.backend.ecommerce.records.InventoryDTO;

import java.util.List;
import java.util.Map;

public interface InventoryService {

    InventoryDTO addInventory(Long productId, Integer stock);
    InventoryDTO updateStock(Long productId, Integer stock);
    InventoryDTO getInventoryByProduct(Long productId) throws InventoryNotFoundException;
    List<InventoryDTO> getAllInventory();
    InventoryDTO increaseStock(Long productId, Integer quantity) throws InventoryNotFoundException;
    InventoryDTO decreaseStock(Long productId, Integer quantity) throws InsufficientStockException, InventoryNotFoundException;
    Boolean isStockAvailable(Long productId, Integer quantity) throws InventoryNotFoundException;
    void bulkUpdateStock(Map<Long, Integer> stockUpdates) throws InventoryNotFoundException;
}


// File: OrderService.java

package com.backend.ecommerce.service;

import com.backend.ecommerce.dto.OrderRequest;
import com.backend.ecommerce.entity.Order;
import com.backend.ecommerce.enums.TransactionType;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;

public interface OrderService {
    void createOrder(OrderRequest orderRequest);

    Order getOrder(Integer id);

    List<Order> getAllOrders();

    Order convertCartToOrder(Long cartId);

}


// File: BankPaymentStrategy.java

//package com.backend.ecommerce.service.payment;
//
//import com.backend.ecommerce.entity.User;
//import com.backend.ecommerce.entity.UserBankDetails;
//import com.backend.ecommerce.repository.UserBankDetailsRepository;
//import org.springframework.stereotype.Service;
//
//import java.math.BigDecimal;
//
//@Service
//public class BankPaymentStrategy implements PaymentStrategy {
//
//    private final UserBankDetailsRepository userBankDetailsRepository;
//
//    public BankPaymentStrategy(UserBankDetailsRepository userBankDetailsRepository) {
//        this.userBankDetailsRepository = userBankDetailsRepository;
//    }
//
//    @Override
//    public boolean processPayment(User user, BigDecimal amount) {
//        UserBankDetails primaryBankDetails = userBankDetailsRepository.findByUserIdAndIsPrimaryTrue(user.getId())
//                .orElseThrow(() -> new RuntimeException("Primary Bank Details Not Found"));
//        // Simulate bank transaction processing
//        System.out.println("Processing bank transaction for account: " + primaryBankDetails.getAccountNumber() + " Amount: " + amount);
//        return true;  // Assume success for simulation
//    }
//}


// File: CheckoutService.java

package com.backend.ecommerce.service.payment;

import com.backend.ecommerce.entity.*;
import com.backend.ecommerce.enums.OrderStatus;
import com.backend.ecommerce.enums.TransactionStatus;
import com.backend.ecommerce.enums.TransactionType;
import com.backend.ecommerce.repository.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class CheckoutService {

    private final UserRepository userRepository;
    private final CartRepository cartRepository;
    private final OrderRepository orderRepository;
    private final TransactionRepository transactionRepository;
    private final CartProductsRepository cartProductsRepository;

    public CheckoutService(UserRepository userRepository, CartRepository cartRepository, OrderRepository orderRepository, TransactionRepository transactionRepository, CartProductsRepository cartProductsRepository) {
        this.userRepository = userRepository;
        this.cartRepository = cartRepository;
        this.orderRepository = orderRepository;
        this.transactionRepository = transactionRepository;
        this.cartProductsRepository = cartProductsRepository;
    }
//    private final PaymentContext paymentContext;



    @Transactional
    public Order checkout(Long userId, TransactionType transactionType, BigDecimal transactionAmount) {
        System.out.println("Fetching user with ID: " + userId);
        User user = userRepository.findById(userId).orElseThrow(() -> new RuntimeException("User Not Found"));
        System.out.println("User found: " + user);

        System.out.println("Fetching cart with ID: " + user.getCart().getId());
        Cart cart = cartRepository.findById(user.getCart().getId()).orElseThrow(() -> new RuntimeException("Cart Not Found"));
        System.out.println("Cart found: " + cart);

        List<CartProducts> cartProducts = cart.getCartProducts();
        if (cartProducts.isEmpty()) {
            throw new RuntimeException("Cart is empty");
        }
        System.out.println("Cart products found: " + cartProducts);

        List<OrderProducts> orderProducts = cartProducts.stream().map(cartProduct -> {
            OrderProducts orderProduct = new OrderProducts();
            orderProduct.setProduct(cartProduct.getProduct());
            orderProduct.setQuantity(cartProduct.getQuantity());
            return orderProduct;
        }).collect(Collectors.toList());

        Order order = new Order();
        order.setUser(user);
        order.setOrderStatus(OrderStatus.PENDING);
        order.setOrderProducts(orderProducts);

        Transaction transaction = new Transaction();
        transaction.setTransactionType(transactionType);
        transaction.setTransactionAmount(transactionAmount);
        transaction.setUser(user);
        transaction.setOrder(order);

//        PaymentStrategy paymentStrategy = paymentContext.getPaymentStrategy(transactionType);
//        boolean isPaymentSuccessful = paymentStrategy.processPayment(user, transactionAmount);
//        if (!isPaymentSuccessful) {
//            throw new RuntimeException("Payment Failed");
//        }

        transaction.setTransactionStatus(TransactionStatus.COMPLETED);

        orderRepository.save(order);
        System.out.println("Order saved: " + order);

        transactionRepository.save(transaction);
        System.out.println("Transaction saved: " + transaction);

        order.setTransaction(transaction);
        orderRepository.save(order);
        System.out.println("Order updated with transaction: " + order);

        for (OrderProducts orderProduct : orderProducts) {
            orderProduct.setOrder(order);
        }

        cartProductsRepository.deleteAll(cartProducts);
        cartRepository.deleteByUserId(userId);
        System.out.println("Cart deleted");

        return order;
    }
}


// File: CreditCardPaymentStrategy.java

//package com.backend.ecommerce.service.payment;
//
//import com.backend.ecommerce.entity.User;
//import org.springframework.stereotype.Service;
//
//import java.math.BigDecimal;
//
//@Service
//public class CreditCardPaymentStrategy implements PaymentStrategy {
//    @Override
//    public boolean processPayment(User user, BigDecimal amount) {
//        // Implement credit card transaction processing logic
//        System.out.println("Processing credit card transaction for user: " + user.getId() + " Amount: " + amount);
//        return true;  // Assume success for simulation
//    }
//}


// File: DebitCardPaymentStrategy.java

//package com.backend.ecommerce.service.payment;
//
//import com.backend.ecommerce.entity.User;
//import org.springframework.stereotype.Service;
//
//import java.math.BigDecimal;
//
//@Service
//public class DebitCardPaymentStrategy implements PaymentStrategy {
//    @Override
//    public boolean processPayment(User user, BigDecimal amount) {
//        // Implement debit card transaction processing logic
//        System.out.println("Processing debit card transaction for user: " + user.getId() + " Amount: " + amount);
//        return true;  // Assume success for simulation
//    }
//}


// File: IMPSPaymentStrategy.java

//// src/main/java/com/backend/ecommerce/service/payment/IMPSPaymentStrategy.java
//package com.backend.ecommerce.service.payment;
//
//import com.backend.ecommerce.entity.User;
//import org.springframework.stereotype.Service;
//
//import java.math.BigDecimal;
//
//@Service
//public class IMPSPaymentStrategy implements PaymentStrategy {
//    @Override
//    public boolean processPayment(User user, BigDecimal amount) {
//        // Implement IMPS transaction processing logic
//        System.out.println("Processing IMPS transaction for user: " + user.getId() + " Amount: " + amount);
//        return true;  // Assume success for simulation
//    }
//}


// File: PaymentContext.java

//package com.backend.ecommerce.service.payment;
//
//
//import com.backend.ecommerce.enums.TransactionType;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.stereotype.Component;
//
//@Component
//public class PaymentContext {
//
//    private final BankPaymentStrategy bankPaymentStrategy;
//    private final CreditCardPaymentStrategy creditCardPaymentStrategy;
//    private final DebitCardPaymentStrategy debitCardPaymentStrategy;
//    private final UPIPaymentStrategy upiPaymentStrategy;
//    private final IMPSPaymentStrategy impsPaymentStrategy;
//
//    @Autowired
//    public PaymentContext(BankPaymentStrategy bankPaymentStrategy,
//                          CreditCardPaymentStrategy creditCardPaymentStrategy,
//                          DebitCardPaymentStrategy debitCardPaymentStrategy,
//                          UPIPaymentStrategy upiPaymentStrategy,
//                          IMPSPaymentStrategy impsPaymentStrategy) {
//        this.bankPaymentStrategy = bankPaymentStrategy;
//        this.creditCardPaymentStrategy = creditCardPaymentStrategy;
//        this.debitCardPaymentStrategy = debitCardPaymentStrategy;
//        this.upiPaymentStrategy = upiPaymentStrategy;
//        this.impsPaymentStrategy = impsPaymentStrategy;
//    }
//
//    public PaymentStrategy getPaymentStrategy(TransactionType transactionType) {
//        return switch (transactionType) {
//            case BANK -> bankPaymentStrategy;
//            case CREDIT_CARD -> creditCardPaymentStrategy;
//            case DEBIT_CARD -> debitCardPaymentStrategy;
//            case UPI -> upiPaymentStrategy;
//            case IMPS -> impsPaymentStrategy;
//            default -> throw new IllegalArgumentException("Unsupported transaction type");
//        };
//    }
//}


// File: PaymentStrategy.java

package com.backend.ecommerce.service.payment;

import com.backend.ecommerce.entity.User;

import java.math.BigDecimal;

public interface PaymentStrategy {
    boolean processPayment(User user, BigDecimal amount);
}


// File: UPIPaymentStrategy.java

//// src/main/java/com/backend/ecommerce/service/payment/UPIPaymentStrategy.java
//package com.backend.ecommerce.service.payment;
//
//import com.backend.ecommerce.entity.User;
//import org.springframework.stereotype.Service;
//
//import java.math.BigDecimal;
//
//@Service
//public class UPIPaymentStrategy implements PaymentStrategy {
//    @Override
//    public boolean processPayment(User user, BigDecimal amount) {
//        // Implement UPI transaction processing logic
//        System.out.println("Processing UPI transaction for user: " + user.getId() + " Amount: " + amount);
//        return true;  // Assume success for simulation
//    }
//}


// File: ProductImageService.java

//package com.backend.ecommerce.service;
//
//import com.backend.ecommerce.entity.ProductImageTable;
//import com.backend.ecommerce.records.ProductImageDTO;
//import org.springframework.web.multipart.MultipartFile;
//
//import java.io.IOException;
//import java.io.InputStream;
//import java.util.List;
//
//public interface ProductImageService {
//    ProductImageDTO saveProductImage(MultipartFile file, Long productId) throws IOException;
//}


// File: ProductReviewService.java

//package com.backend.ecommerce.service;
//
//import com.backend.ecommerce.entity.ProductReview;
//import org.springframework.stereotype.Service;
//
//import java.util.List;
//
//public interface ProductReviewService {
//    ProductReview create(ProductReview productReview);
//
//    ProductReview update(int productReviewId, ProductReview productReview);
//
//    void delete(int productReviewId);
//
//    List<ProductReview> findByProductId(Long productId);
//
//    List<ProductReview> findByUserId(Long userId);
//}


// File: ProductService.java

package com.backend.ecommerce.service;

import com.backend.ecommerce.entity.Product;
import com.backend.ecommerce.records.ProductDTO;
import com.backend.ecommerce.records.ProductResponse;

import java.util.List;

public interface ProductService {
    ProductDTO createProduct(Product product);

    List<ProductDTO> addAll(List<Product> productList);

    List<ProductDTO> getAllProducts();

    ProductDTO getProductById(Long id);

    ProductDTO updateProduct(Long id, Product product);

    List<ProductDTO> getProductByCategory(Long catId);

    ProductDTO assignCategoryToProduct(Long productId, Long categoryId);

    ProductDTO deleteProduct(Long id);

    ProductResponse getAllProductWithPagination(Integer pageNo, Integer pageSize);

    ProductResponse getProductWithPaginationAndSorting(Integer pageNo, Integer pageSize, String sortBy, String sortOrder);

    ProductResponse searchProducts(String query, Integer pageNumber, Integer pageSize, String sortBy, String sortOrder);

    List<Product> searchProducts(String query);

}


// File: SizeService.java

package com.backend.ecommerce.service;

import com.backend.ecommerce.entity.Size;
import org.springframework.stereotype.Service;

import java.util.List;

public interface SizeService {
    Size createSize(Size size);
    List<Size> getAllSizes();
}


// File: TransactionService.java

package com.backend.ecommerce.service;

import com.backend.ecommerce.entity.Transaction;

import java.util.List;

public interface TransactionService {
    List<Transaction> getAllTransactions();

    Transaction getTransactionById(Long id);

    Transaction saveTransaction(Transaction transaction);

    void deleteTransaction(Long id);

    Transaction updateTransaction(Transaction transaction, Long id);
}


// File: UserBankDetailsService.java

//package com.backend.ecommerce.service;
//
//import com.backend.ecommerce.entity.UserBankDetails;
//import org.springframework.stereotype.Service;
//
//import java.util.List;
//import java.util.Optional;
//
//@Service
//public interface UserBankDetailsService {
//
//    List<UserBankDetails> getAllBankDetails();
//
//    Optional<UserBankDetails> getBankDetailsById(Long id);
//
//    List<UserBankDetails> getBankDetailsByUserId(Long userId);
//
//    List<UserBankDetails> getPrimaryBankDetails(Boolean isPrimary);
//
//    List<UserBankDetails> getBankDetailsByStatus(String status);
//
//    UserBankDetails saveBankDetails(Long userId, UserBankDetails bankDetails);
//
//    void deleteBankDetails(Long id);
//}


// File: UserService.java

package com.backend.ecommerce.service;

import com.backend.ecommerce.records.UserDTO;

import java.util.List;

public interface UserService {
//    UserDTO createUser(UserDTO userDTO);

    UserDTO getUserById(Long id);

    List<UserDTO> getAllUsers();

    UserDTO updateUser(Long userId, UserDTO userDTO);

    void deleteUser(Long id);

    UserDTO getUserByEmail(String email);
}


// File: AppConstants.java

package com.backend.ecommerce.utility;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public final class AppConstants {
    public static final String PAGE_NUMBER = "0";
    public static final String PAGE_SIZE = "10";
    public static final String SORT_BY = "productId";
    public static final String SORT_ORDER = "asc";
    public static final String[] EXCEPTION_APIS = {"/api/auth/**","/api/users/**","/api/products/**","/api/inventory/**","/forgotPassword/**","/v2/api-docs/","/swagger-resources/**","/swagger-ui/**","/webjars/**","/api/category"};

}


// File: JwtBlacklistService.java

package com.backend.ecommerce.utility;

import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.Set;

@Service
public class JwtBlacklistService {
    private final Set<String> blacklist = new HashSet<>();

    public void addBlacklist(String token) {
        blacklist.add(token);
    }
    public boolean isBlacklisted(String token) {
        return blacklist.contains(token);
    }
}


// File: Utility.java

package com.backend.ecommerce.utility;

import org.springframework.beans.BeanWrapper;
import org.springframework.beans.BeanWrapperImpl;

import java.util.HashSet;
import java.util.Set;

public class Utility {

    public static String[] getNullPropertyNames(Object source) {
        final BeanWrapper src = new BeanWrapperImpl(source);
        Set<String> propertyNames = new HashSet<>();
        for (java.beans.PropertyDescriptor descriptor : src.getPropertyDescriptors()) {
            if (src.getPropertyValue(descriptor.getName()) == null) {
                propertyNames.add(descriptor.getName());
            }
        }
        return propertyNames.toArray(new String[propertyNames.size()]);
    }
}


// File: ECommerceApplicationTests.java

package com.backend.ecommerce;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ECommerceApplicationTests {

	@Test
	void contextLoads() {
	}

}


